#this is the structure of the project
#  database
#  	db_manager.py	
#  pages
#	home.py
#	login.py
# 	signup.py
#	dashboard
#		chat.py
#		documents.py
#		flashcard.py
#		main.py
#		planner.py	
#		quiz.py	
#		settings.py	
#		subjects.py
#  utils
#	auth.py
#	document_processor.py
#	rag_system.py
#  app.py
#


#
#This is the database/db_manager.py
import sqlite3
from datetime import datetime
from typing import Optional, List, Dict, Any
from contextlib import contextmanager
from cryptography.fernet import Fernet
import os
import json


class DatabaseManager:
    """Manages all database operations for the AI Study Assistant"""
    
    def __init__(self, db_path: str = "study_assistant.db"):
        self.db_path = db_path
        # Get encryption key from environment variable
        encryption_key = os.getenv('ENCRYPTION_KEY')
        if not encryption_key:
            # Try to load from .encryption_key file
            key_file = '.encryption_key'
            if os.path.exists(key_file):
                with open(key_file, 'r') as f:
                    encryption_key = f.read().strip()
            else:
                # Generate a new key if none exists (for first run)
                encryption_key = Fernet.generate_key().decode()
                # Save it to file
                with open(key_file, 'w') as f:
                    f.write(encryption_key)
                print(f"‚ö†Ô∏è WARNING: Generated new encryption key and saved to {key_file}")
                print(f"Add this to your .env file: ENCRYPTION_KEY={encryption_key}")
        
        self.cipher = Fernet(encryption_key.encode() if isinstance(encryption_key, str) else encryption_key)
        self.initialize_database()
    
    @contextmanager
    def get_connection(self):
        """Context manager for database connections"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # Enable column access by name
        try:
            yield conn
            conn.commit()
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()
    
    def initialize_database(self):
        """Create all tables if they don't exist"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            # Users table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    email TEXT UNIQUE NOT NULL,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_login TIMESTAMP
                )
            ''')
            
            # User settings table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL UNIQUE,
                    azure_api_key TEXT,
                    azure_endpoint TEXT,
                    azure_deployment_name TEXT,
                    azure_api_version TEXT DEFAULT '2024-02-15-preview',
                    embedding_model TEXT DEFAULT 'text-embedding-ada-002',
                    chat_model TEXT DEFAULT 'gpt-4',
                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )
            ''')
            
            # Subjects table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS subjects (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    name TEXT NOT NULL,
                    description TEXT,
                    color TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )
            ''')
            
            # Documents table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS documents (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    subject_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    title TEXT NOT NULL,
                    file_path TEXT,
                    file_type TEXT,
                    file_size INTEGER,
                    faiss_index_path TEXT,
                    upload_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    processing_status TEXT DEFAULT 'pending',
                    chunk_count INTEGER,
                    FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE CASCADE,
                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )
            ''')
            
            # Chat history table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS chat_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    document_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    role TEXT NOT NULL,
                    message TEXT NOT NULL,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    tokens_used INTEGER,
                    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE,
                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )
            ''')
            
            # Quizzes table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS quizzes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    document_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    title TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE,
                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )
            ''')
            
            # Quiz questions table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS quiz_questions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    quiz_id INTEGER NOT NULL,
                    question TEXT NOT NULL,
                    correct_answer TEXT NOT NULL,
                    option_a TEXT,
                    option_b TEXT,
                    option_c TEXT,
                    option_d TEXT,
                    explanation TEXT,
                    FOREIGN KEY (quiz_id) REFERENCES quizzes(id) ON DELETE CASCADE
                )
            ''')
            
            # Quiz attempts table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS quiz_attempts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    quiz_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    attempt_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    score REAL,
                    time_taken INTEGER,
                    FOREIGN KEY (quiz_id) REFERENCES quizzes(id) ON DELETE CASCADE,
                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )
            ''')
            
            # Quiz answers table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS quiz_answers (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    attempt_id INTEGER NOT NULL,
                    question_id INTEGER NOT NULL,
                    user_answer TEXT NOT NULL,
                    is_correct BOOLEAN,
                    FOREIGN KEY (attempt_id) REFERENCES quiz_attempts(id) ON DELETE CASCADE,
                    FOREIGN KEY (question_id) REFERENCES quiz_questions(id) ON DELETE CASCADE
                )
            ''')
            
            # Flashcard sets table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS flashcard_sets (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    document_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    title TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE,
                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )
            ''')
            
            # Flashcard items table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS flashcard_items (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    flashcard_set_id INTEGER NOT NULL,
                    front TEXT NOT NULL,
                    back TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (flashcard_set_id) REFERENCES flashcard_sets(id) ON DELETE CASCADE
                )
            ''')
            
            # Flashcard reviews table (for spaced repetition)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS flashcard_reviews (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    flashcard_item_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    difficulty INTEGER,
                    review_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    next_review_date TIMESTAMP,
                    FOREIGN KEY (flashcard_item_id) REFERENCES flashcard_items(id) ON DELETE CASCADE,
                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )
            ''')
            
            # Tasks table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS tasks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    subject_id INTEGER,
                    title TEXT NOT NULL,
                    description TEXT,
                    due_date DATE,
                    priority TEXT DEFAULT 'medium',
                    status TEXT DEFAULT 'pending',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    completed_at TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                    FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE SET NULL
                )
            ''')
            
            # Processing logs table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS processing_logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    document_id INTEGER NOT NULL,
                    status TEXT NOT NULL,
                    message TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE
                )
            ''')
            
            # Create indexes for better performance
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_subjects_user ON subjects(user_id)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_documents_subject ON documents(subject_id)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_documents_user ON documents(user_id)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_chat_history_document ON chat_history(document_id)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_chat_history_user ON chat_history(user_id)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_tasks_user ON tasks(user_id)')
    
    # ==================== ENCRYPTION METHODS ====================
    
    def encrypt_api_key(self, api_key: str) -> str:
        """Encrypt API key before storing"""
        return self.cipher.encrypt(api_key.encode()).decode()
    
    def decrypt_api_key(self, encrypted_key: str) -> str:
        """Decrypt API key when retrieving"""
        return self.cipher.decrypt(encrypted_key.encode()).decode()
    
    # ==================== USER METHODS ====================
    
    def create_user(self, email: str, username: str, password_hash: str) -> Optional[int]:
        """Create a new user"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO users (email, username, password_hash)
                    VALUES (?, ?, ?)
                ''', (email, username, password_hash))
                return cursor.lastrowid
        except sqlite3.IntegrityError:
            return None
    
    def get_user_by_email(self, email: str) -> Optional[Dict]:
        """Get user by email"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM users WHERE email = ?', (email,))
            row = cursor.fetchone()
            return dict(row) if row else None
    
    def get_user_by_username(self, username: str) -> Optional[Dict]:
        """Get user by username"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM users WHERE username = ?', (username,))
            row = cursor.fetchone()
            return dict(row) if row else None
    
    def update_last_login(self, user_id: int):
        """Update user's last login timestamp"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE users SET last_login = CURRENT_TIMESTAMP
                WHERE id = ?
            ''', (user_id,))
    
    # ==================== USER SETTINGS METHODS ====================
    
    def save_user_settings(self, user_id: int, azure_api_key: str, azure_endpoint: str, 
                          azure_deployment_name: str, azure_api_version: str = '2024-02-15-preview',
                          embedding_model: str = 'text-embedding-ada-002',
                          chat_model: str = 'gpt-4') -> bool:
        """Save or update user's Azure OpenAI settings"""
        encrypted_key = self.encrypt_api_key(azure_api_key)
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO user_settings (user_id, azure_api_key, azure_endpoint, 
                                         azure_deployment_name, azure_api_version,
                                         embedding_model, chat_model)
                VALUES (?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(user_id) DO UPDATE SET
                    azure_api_key = excluded.azure_api_key,
                    azure_endpoint = excluded.azure_endpoint,
                    azure_deployment_name = excluded.azure_deployment_name,
                    azure_api_version = excluded.azure_api_version,
                    embedding_model = excluded.embedding_model,
                    chat_model = excluded.chat_model
            ''', (user_id, encrypted_key, azure_endpoint, azure_deployment_name, 
                  azure_api_version, embedding_model, chat_model))
            return True
    
    def get_user_settings(self, user_id: int) -> Optional[Dict]:
        """Get user's settings with decrypted API key"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM user_settings WHERE user_id = ?', (user_id,))
            row = cursor.fetchone()
            if row:
                settings = dict(row)
                if settings.get('azure_api_key'):
                    settings['azure_api_key'] = self.decrypt_api_key(settings['azure_api_key'])
                return settings
            return None
    
    # ==================== SUBJECT METHODS ====================
    
    def create_subject(self, user_id: int, name: str, description: str = None, 
                       color: str = None) -> int:
        """Create a new subject"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO subjects (user_id, name, description, color)
                VALUES (?, ?, ?, ?)
            ''', (user_id, name, description, color))
            return cursor.lastrowid
    
    def get_user_subjects(self, user_id: int) -> List[Dict]:
        """Get all subjects for a user"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM subjects WHERE user_id = ?
                ORDER BY created_at DESC
            ''', (user_id,))
            return [dict(row) for row in cursor.fetchall()]
    
    def get_subject(self, subject_id: int) -> Optional[Dict]:
        """Get a specific subject"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM subjects WHERE id = ?', (subject_id,))
            row = cursor.fetchone()
            return dict(row) if row else None
    
    def update_subject(self, subject_id: int, name: str = None, 
                       description: str = None, color: str = None):
        """Update subject details"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            updates = []
            params = []
            if name:
                updates.append("name = ?")
                params.append(name)
            if description is not None:
                updates.append("description = ?")
                params.append(description)
            if color:
                updates.append("color = ?")
                params.append(color)
            
            if updates:
                params.append(subject_id)
                cursor.execute(f'''
                    UPDATE subjects SET {', '.join(updates)}
                    WHERE id = ?
                ''', params)
    
    def delete_subject(self, subject_id: int):
        """Delete a subject (cascades to documents)"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('DELETE FROM subjects WHERE id = ?', (subject_id,))
    
    # ==================== DOCUMENT METHODS ====================
    
    def create_document(self, subject_id: int, user_id: int, title: str, 
                       file_path: str, file_type: str, file_size: int) -> int:
        """Create a new document"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO documents (subject_id, user_id, title, file_path, 
                                     file_type, file_size, processing_status)
                VALUES (?, ?, ?, ?, ?, ?, 'pending')
            ''', (subject_id, user_id, title, file_path, file_type, file_size))
            return cursor.lastrowid
    
    def get_subject_documents(self, subject_id: int) -> List[Dict]:
        """Get all documents for a subject"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM documents WHERE subject_id = ?
                ORDER BY upload_date DESC
            ''', (subject_id,))
            return [dict(row) for row in cursor.fetchall()]
    
    def get_document(self, document_id: int) -> Optional[Dict]:
        """Get a specific document"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM documents WHERE id = ?', (document_id,))
            row = cursor.fetchone()
            return dict(row) if row else None
    
    def update_document_processing(self, document_id: int, status: str, 
                                   faiss_index_path: str = None, 
                                   chunk_count: int = None):
        """Update document processing status"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            if faiss_index_path and chunk_count:
                cursor.execute('''
                    UPDATE documents 
                    SET processing_status = ?, faiss_index_path = ?, chunk_count = ?
                    WHERE id = ?
                ''', (status, faiss_index_path, chunk_count, document_id))
            else:
                cursor.execute('''
                    UPDATE documents SET processing_status = ?
                    WHERE id = ?
                ''', (status, document_id))
    
    def delete_document(self, document_id: int):
        """Delete a document"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('DELETE FROM documents WHERE id = ?', (document_id,))
    
    # ==================== CHAT HISTORY METHODS ====================
    
    def add_chat_message(self, document_id: int, user_id: int, role: str, 
                        message: str, tokens_used: int = None) -> int:
        """Add a chat message"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO chat_history (document_id, user_id, role, message, tokens_used)
                VALUES (?, ?, ?, ?, ?)
            ''', (document_id, user_id, role, message, tokens_used))
            return cursor.lastrowid
    
    def get_chat_history(self, document_id: int, limit: int = 50) -> List[Dict]:
        """Get chat history for a document"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM chat_history 
                WHERE document_id = ?
                ORDER BY timestamp ASC
                LIMIT ?
            ''', (document_id, limit))
            return [dict(row) for row in cursor.fetchall()]
    
    def clear_chat_history(self, document_id: int):
        """Clear chat history for a document"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('DELETE FROM chat_history WHERE document_id = ?', (document_id,))
    
    # ==================== QUIZ METHODS ====================
    
    def create_quiz(self, document_id: int, user_id: int, title: str) -> int:
        """Create a new quiz"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO quizzes (document_id, user_id, title)
                VALUES (?, ?, ?)
            ''', (document_id, user_id, title))
            return cursor.lastrowid
    
    def add_quiz_question(self, quiz_id: int, question: str, correct_answer: str,
                         option_a: str = None, option_b: str = None,
                         option_c: str = None, option_d: str = None,
                         explanation: str = None) -> int:
        """Add a question to a quiz"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO quiz_questions 
                (quiz_id, question, correct_answer, option_a, option_b, option_c, option_d, explanation)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (quiz_id, question, correct_answer, option_a, option_b, option_c, option_d, explanation))
            return cursor.lastrowid
    
    def get_document_quizzes(self, document_id: int) -> List[Dict]:
        """Get all quizzes for a document"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM quizzes WHERE document_id = ?
                ORDER BY created_at DESC
            ''', (document_id,))
            return [dict(row) for row in cursor.fetchall()]
    
    def get_quiz_questions(self, quiz_id: int) -> List[Dict]:
        """Get all questions for a quiz"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM quiz_questions WHERE quiz_id = ?
            ''', (quiz_id,))
            return [dict(row) for row in cursor.fetchall()]
    
    def create_quiz_attempt(self, quiz_id: int, user_id: int) -> int:
        """Create a new quiz attempt"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO quiz_attempts (quiz_id, user_id)
                VALUES (?, ?)
            ''', (quiz_id, user_id))
            return cursor.lastrowid
    
    def add_quiz_answer(self, attempt_id: int, question_id: int, 
                       user_answer: str, is_correct: bool):
        """Record an answer for a quiz attempt"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO quiz_answers (attempt_id, question_id, user_answer, is_correct)
                VALUES (?, ?, ?, ?)
            ''', (attempt_id, question_id, user_answer, is_correct))
    
    def complete_quiz_attempt(self, attempt_id: int, score: float, time_taken: int):
        """Update quiz attempt with final score"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE quiz_attempts 
                SET score = ?, time_taken = ?
                WHERE id = ?
            ''', (score, time_taken, attempt_id))
    
    def get_quiz_attempts(self, quiz_id: int) -> List[Dict]:
        """Get all attempts for a quiz"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM quiz_attempts WHERE quiz_id = ?
                ORDER BY attempt_date DESC
            ''', (quiz_id,))
            return [dict(row) for row in cursor.fetchall()]
    
    def delete_quiz(self, quiz_id: int):
        """Delete a quiz (cascades to questions, attempts, and answers)"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('DELETE FROM quizzes WHERE id = ?', (quiz_id,))
    
    # ==================== FLASHCARD METHODS ====================
    
    def create_flashcard_set(self, document_id: int, user_id: int, title: str) -> int:
        """Create a new flashcard set"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO flashcard_sets (document_id, user_id, title)
                VALUES (?, ?, ?)
            ''', (document_id, user_id, title))
            return cursor.lastrowid
    
    def add_flashcard(self, flashcard_set_id: int, front: str, back: str) -> int:
        """Add a flashcard to a set"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO flashcard_items (flashcard_set_id, front, back)
                VALUES (?, ?, ?)
            ''', (flashcard_set_id, front, back))
            return cursor.lastrowid
    
    def get_document_flashcard_sets(self, document_id: int) -> List[Dict]:
        """Get all flashcard sets for a document"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM flashcard_sets WHERE document_id = ?
                ORDER BY created_at DESC
            ''', (document_id,))
            return [dict(row) for row in cursor.fetchall()]
    
    def get_flashcards(self, flashcard_set_id: int) -> List[Dict]:
        """Get all flashcards in a set"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM flashcard_items WHERE flashcard_set_id = ?
            ''', (flashcard_set_id,))
            return [dict(row) for row in cursor.fetchall()]
    
    def add_flashcard_review(self, flashcard_item_id: int, user_id: int, 
                            difficulty: int, next_review_date: str = None):
        """Record a flashcard review (for spaced repetition)"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO flashcard_reviews 
                (flashcard_item_id, user_id, difficulty, next_review_date)
                VALUES (?, ?, ?, ?)
            ''', (flashcard_item_id, user_id, difficulty, next_review_date))
    
    # ==================== TASK/PLANNER METHODS ====================
    
    def create_task(self, user_id: int, title: str, description: str = None,
                   due_date: str = None, priority: str = 'medium', 
                   subject_id: int = None) -> int:
        """Create a new task"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO tasks (user_id, subject_id, title, description, due_date, priority)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (user_id, subject_id, title, description, due_date, priority))
            return cursor.lastrowid
    
    def get_user_tasks(self, user_id: int, status: str = None) -> List[Dict]:
        """Get tasks for a user, optionally filtered by status"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            if status:
                cursor.execute('''
                    SELECT * FROM tasks WHERE user_id = ? AND status = ?
                    ORDER BY due_date ASC, priority DESC
                ''', (user_id, status))
            else:
                cursor.execute('''
                    SELECT * FROM tasks WHERE user_id = ?
                    ORDER BY due_date ASC, priority DESC
                ''', (user_id,))
            return [dict(row) for row in cursor.fetchall()]
    
    def update_task_status(self, task_id: int, status: str):
        """Update task status"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            completed_at = datetime.now().isoformat() if status == 'completed' else None
            cursor.execute('''
                UPDATE tasks SET status = ?, completed_at = ?
                WHERE id = ?
            ''', (status, completed_at, task_id))
    
    def delete_task(self, task_id: int):
        """Delete a task"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('DELETE FROM tasks WHERE id = ?', (task_id,))
    
    # ==================== PROCESSING LOG METHODS ====================
    
    def add_processing_log(self, document_id: int, status: str, message: str = None):
        """Add a processing log entry"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO processing_logs (document_id, status, message)
                VALUES (?, ?, ?)
            ''', (document_id, status, message))
    
    def get_processing_logs(self, document_id: int) -> List[Dict]:
        """Get processing logs for a document"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM processing_logs WHERE document_id = ?
                ORDER BY timestamp DESC
            ''', (document_id,))
            return [dict(row) for row in cursor.fetchall()]



#This is the pages/home.py

import streamlit as st
from utils.auth import AuthManager


def show_home_page(auth: AuthManager, navigate_to):
    """
    Display the home/landing page
    
    Args:
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    # Hero section
    st.markdown("""
        <div style='text-align: center; padding: 2rem 0;'>
            <h1 style='font-size: 3.5rem; color: #1f77b4; margin-bottom: 0;'>
                üìö AI Study Assistant
            </h1>
            <p style='font-size: 1.5rem; color: #666; margin-top: 0.5rem;'>
                Transform the way you study with AI-powered learning
            </p>
        </div>
    """, unsafe_allow_html=True)
    
    # If already authenticated, show quick access
    if auth.is_authenticated():
        st.success(f"‚úÖ You're logged in as **{auth.get_current_username()}**")
        
        col1, col2, col3 = st.columns([1, 1, 1])
        
        with col1:
            st.markdown("")
        
        with col2:
            if st.button("üìä Go to Dashboard", type="primary", use_container_width=True):
                navigate_to('dashboard')
        
        with col3:
            st.markdown("")
        
        st.markdown("---")
    
    # Features section
    st.markdown("## ‚ú® Key Features")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("""
        ### üìñ **Organize Your Materials**
        - Create subjects for different courses
        - Upload unlimited documents per subject
        - Support for PDF, DOCX, and TXT files
        - Automatic text extraction and processing
        """)
        
        st.markdown("""
        ### üí¨ **Chat with Your Documents**
        - Ask questions about your study materials
        - Get instant, accurate answers with citations
        - AI understands context from your documents
        - Maintain conversation history for reference
        """)
        
        st.markdown("""
        ### ‚ùì **Generate Quizzes**
        - Auto-generate multiple-choice questions
        - Customize difficulty level and topic focus
        - Track your quiz history and scores
        - Get detailed explanations for answers
        """)
    
    with col2:
        st.markdown("""
        ### üé¥ **Create Flashcards**
        - AI-generated flashcards from your content
        - Study with spaced repetition
        - Track which cards you've mastered
        - Perfect for memorization and review
        """)
        
        st.markdown("""
        ### üìÖ **Plan Your Studies**
        - Create study tasks and set deadlines
        - Organize tasks by subject
        - Track completion status
        - Never miss an important deadline
        """)
        
        st.markdown("""
        ### üîê **Private & Secure**
        - Your data stays yours
        - Use your own Azure OpenAI API keys
        - Encrypted storage of credentials
        - Complete control over your information
        """)
    
    st.markdown("---")
    
    # How it works section
    st.markdown("## üöÄ How It Works")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown("""
        <div style='text-align: center; padding: 1rem;'>
            <h2 style='font-size: 3rem; margin: 0;'>1Ô∏è‚É£</h2>
            <h4>Sign Up</h4>
            <p>Create your free account in seconds</p>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='text-align: center; padding: 1rem;'>
            <h2 style='font-size: 3rem; margin: 0;'>2Ô∏è‚É£</h2>
            <h4>Add API Keys</h4>
            <p>Configure your Azure OpenAI credentials</p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown("""
        <div style='text-align: center; padding: 1rem;'>
            <h2 style='font-size: 3rem; margin: 0;'>3Ô∏è‚É£</h2>
            <h4>Upload Documents</h4>
            <p>Add your study materials by subject</p>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown("""
        <div style='text-align: center; padding: 1rem;'>
            <h2 style='font-size: 3rem; margin: 0;'>4Ô∏è‚É£</h2>
            <h4>Start Learning</h4>
            <p>Chat, quiz, and study smarter</p>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("---")
    
    # Technology section
    st.markdown("## üõ†Ô∏è Powered By")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        **Azure OpenAI**
        - GPT-4 for intelligent responses
        - Advanced text embeddings
        - Enterprise-grade AI
        """)
    
    with col2:
        st.markdown("""
        **FAISS Vector Store**
        - Lightning-fast semantic search
        - Efficient document retrieval
        - Scalable architecture
        """)
    
    with col3:
        st.markdown("""
        **RAG Technology**
        - Retrieval-Augmented Generation
        - Accurate, context-aware answers
        - Reduces AI hallucinations
        """)
    
    st.markdown("---")
    
    # CTA section
    if not auth.is_authenticated():
        st.markdown("## üéØ Ready to Transform Your Studies?")
        
        col1, col2, col3 = st.columns([1, 2, 1])
        
        with col1:
            st.markdown("")
        
        with col2:
            st.markdown("""
            <div style='text-align: center; padding: 1rem;'>
                <p style='font-size: 1.2rem; margin-bottom: 1.5rem;'>
                    Join students who are studying smarter with AI
                </p>
            </div>
            """, unsafe_allow_html=True)
            
            col_a, col_b = st.columns(2)
            
            with col_a:
                if st.button("üìù Sign Up Now", type="primary", use_container_width=True):
                    navigate_to('signup')
            
            with col_b:
                if st.button("üîê Login", use_container_width=True):
                    navigate_to('login')
        
        with col3:
            st.markdown("")
    
    # Footer
    st.markdown("---")
    st.markdown("""
        <div style='text-align: center; color: #666; padding: 2rem 0;'>
            <p>Made with ‚ù§Ô∏è for students | AI Study Assistant ¬© 2024</p>
            <p style='font-size: 0.9rem;'>
                This is a diploma project demonstrating AI-powered education technology
            </p>
        </div>
    """, unsafe_allow_html=True)


#this is pages/login.py


import streamlit as st
from utils.auth import AuthManager


def show_login_page(auth: AuthManager, navigate_to):
    """
    Display the login page
    
    Args:
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    # Center the login form
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        # Header
        st.markdown("""
            <div style='text-align: center; padding: 2rem 0 1rem 0;'>
                <h1 style='color: #1f77b4;'>üîê Login</h1>
                <p style='color: #666;'>Welcome back! Please login to your account</p>
            </div>
        """, unsafe_allow_html=True)
        
        # Login form
        with st.form("login_form", clear_on_submit=False):
            email_or_username = st.text_input(
                "Email or Username",
                placeholder="Enter your email or username",
                help="You can login with either your email or username"
            )
            
            password = st.text_input(
                "Password",
                type="password",
                placeholder="Enter your password"
            )
            
            # Remember me checkbox (optional feature for future)
            remember_me = st.checkbox("Remember me", value=False)
            
            # Submit button
            col_a, col_b = st.columns(2)
            with col_a:
                submit = st.form_submit_button("Login", type="primary", use_container_width=True)
            with col_b:
                if st.form_submit_button("Cancel", use_container_width=True):
                    navigate_to('home')
            
            if submit:
                if not email_or_username or not password:
                    st.error("‚ö†Ô∏è Please fill in all fields")
                else:
                    # Attempt login
                    with st.spinner("Logging in..."):
                        success, message = auth.login(email_or_username, password)
                    
                    if success:
                        st.success(f"‚úÖ {message}")
                        st.balloons()
                        # Small delay to show success message
                        import time
                        time.sleep(1)
                        navigate_to('dashboard')
                    else:
                        st.error(f"‚ùå {message}")
        
        # Divider
        st.markdown("---")
        
        # Additional options
        col_x, col_y = st.columns(2)
        
        with col_x:
            st.markdown("**Don't have an account?**")
            if st.button("Sign Up", use_container_width=True):
                navigate_to('signup')
        
        with col_y:
            st.markdown("**Forgot password?**")
            if st.button("Reset Password", use_container_width=True, disabled=True):
                st.info("Password reset feature coming soon!")
        
        # Info box
        st.markdown("---")
        st.info("""
        **üí° First time here?**
        
        1. Create an account by clicking "Sign Up"
        2. Add your Azure OpenAI API credentials in Settings
        3. Start uploading your study materials
        4. Begin learning with AI assistance!
        """)
        
        # Back to home link
        st.markdown("""
            <div style='text-align: center; margin-top: 2rem;'>
                <p style='color: #666;'>
                    Want to learn more first?
                </p>
            </div>
        """, unsafe_allow_html=True)
        
        if st.button("‚Üê Back to Home", use_container_width=True):
            navigate_to('home')


#This is pages/signup.py


import streamlit as st
from utils.auth import AuthManager


def show_signup_page(auth: AuthManager, navigate_to):
    """
    Display the signup/registration page
    
    Args:
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    # Center the signup form
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        # Header
        st.markdown("""
            <div style='text-align: center; padding: 2rem 0 1rem 0;'>
                <h1 style='color: #1f77b4;'>üìù Sign Up</h1>
                <p style='color: #666;'>Create your account and start studying smarter</p>
            </div>
        """, unsafe_allow_html=True)
        
        # Signup form
        with st.form("signup_form", clear_on_submit=False):
            email = st.text_input(
                "Email *",
                placeholder="your.email@example.com",
                help="We'll never share your email with anyone"
            )
            
            username = st.text_input(
                "Username *",
                placeholder="Choose a unique username",
                help="3-20 characters, letters, numbers, and underscores only",
                max_chars=20
            )
            
            col_pass1, col_pass2 = st.columns(2)
            
            with col_pass1:
                password = st.text_input(
                    "Password *",
                    type="password",
                    placeholder="Create a strong password"
                )
            
            with col_pass2:
                confirm_password = st.text_input(
                    "Confirm Password *",
                    type="password",
                    placeholder="Re-enter your password"
                )
            
            # Password requirements info
            with st.expander("‚ÑπÔ∏è Password Requirements"):
                st.markdown("""
                Your password must contain:
                - At least **8 characters**
                - At least **one uppercase letter** (A-Z)
                - At least **one lowercase letter** (a-z)
                - At least **one digit** (0-9)
                """)
            
            # Terms and conditions
            terms_accepted = st.checkbox(
                "I agree to the Terms of Service and Privacy Policy",
                value=False
            )
            
            # Submit buttons
            col_a, col_b = st.columns(2)
            with col_a:
                submit = st.form_submit_button("Create Account", type="primary", use_container_width=True)
            with col_b:
                if st.form_submit_button("Cancel", use_container_width=True):
                    navigate_to('home')
            
            if submit:
                # Validate inputs
                if not all([email, username, password, confirm_password]):
                    st.error("‚ö†Ô∏è Please fill in all required fields")
                elif not terms_accepted:
                    st.warning("‚ö†Ô∏è Please accept the Terms of Service to continue")
                else:
                    # Attempt signup
                    with st.spinner("Creating your account..."):
                        success, message = auth.signup(email, username, password, confirm_password)
                    
                    if success:
                        st.success(f"‚úÖ {message}")
                        st.balloons()
                        st.info("üëâ Please login with your new credentials")
                        
                        # Small delay then navigate to login
                        import time
                        time.sleep(2)
                        navigate_to('login')
                    else:
                        st.error(f"‚ùå {message}")
        
        # Divider
        st.markdown("---")
        
        # Link to login
        st.markdown("**Already have an account?**")
        if st.button("Login Here", use_container_width=True):
            navigate_to('login')
        
        # Info boxes
        st.markdown("---")
        
        # What you'll get
        st.success("""
        **‚ú® What you'll get with your account:**
        
        - üìö Unlimited subjects and documents
        - üí¨ AI-powered chat with your materials
        - ‚ùì Automatic quiz generation
        - üé¥ Smart flashcard creation
        - üìÖ Integrated study planner
        - üîê Secure, encrypted data storage
        """)
        
        # Privacy notice
        st.info("""
        **üîí Your Privacy Matters**
        
        We take your privacy seriously. Your documents and API keys are stored securely and encrypted. 
        We never share your data with third parties. You maintain full control over your information.
        """)
        
        # Back to home link
        st.markdown("""
            <div style='text-align: center; margin-top: 2rem;'>
                <p style='color: #666;'>
                    Want to learn more first?
                </p>
            </div>
        """, unsafe_allow_html=True)
        
        if st.button("‚Üê Back to Home", use_container_width=True):
            navigate_to('home')

#this is pages/dashboard/chat.py
import streamlit as st
from utils.auth import AuthManager
from database.db_manager import DatabaseManager
from utils.rag_system import RAGSystem
from datetime import datetime


def show_chat_page(db: DatabaseManager, auth: AuthManager, navigate_to):
    """
    Display the chat interface for documents
    
    Args:
        db: DatabaseManager instance
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    # Page header
    st.markdown("""
        <div style='padding: 1rem 0;'>
            <h1 style='color: #1f77b4;'>üí¨ Chat with Documents</h1>
            <p style='color: #666; font-size: 1.1rem;'>Ask questions and get answers from your study materials</p>
        </div>
    """, unsafe_allow_html=True)
    
    user_id = auth.get_current_user_id()
    
    # Check Azure settings
    if not auth.has_azure_settings():
        st.warning("‚ö†Ô∏è **Azure OpenAI settings not configured**")
        if st.button("‚öôÔ∏è Go to Settings", type="primary"):
            navigate_to('settings')
        return
    
    # Get user settings
    settings = db.get_user_settings(user_id)
    
    # Get subjects
    subjects = db.get_user_subjects(user_id)
    
    if not subjects:
        st.warning("üìö **No subjects found**")
        st.info("Create a subject and upload documents first.")
        if st.button("‚ûï Create Subject", type="primary"):
            navigate_to('subjects')
        return
    
    # Subject selector
    st.markdown("### üìö Select Subject")
    
    selected_subject_id = st.session_state.get('selected_subject_id')
    subject_options = {f"{s['name']}": s['id'] for s in subjects}
    
    if selected_subject_id:
        selected_subject = db.get_subject(selected_subject_id)
        if selected_subject:
            default_index = list(subject_options.keys()).index(selected_subject['name'])
        else:
            default_index = 0
    else:
        default_index = 0
    
    selected_subject_name = st.selectbox(
        "Choose a subject",
        options=list(subject_options.keys()),
        index=default_index,
        key="chat_subject_selector"
    )
    
    current_subject_id = subject_options[selected_subject_name]
    st.session_state.selected_subject_id = current_subject_id
    
    # Get documents for subject
    documents = db.get_subject_documents(current_subject_id)
    completed_docs = [d for d in documents if d['processing_status'] == 'completed']
    
    if not completed_docs:
        st.warning(f"üìÑ **No processed documents in this subject**")
        st.info("Upload and process documents first.")
        if st.button("üì§ Upload Document", type="primary"):
            navigate_to('documents')
        return
    
    # Document selector
    st.markdown("### üìÑ Select Document")
    
    selected_document_id = st.session_state.get('selected_document_id')
    doc_options = {f"{d['title']}": d['id'] for d in completed_docs}
    
    if selected_document_id and selected_document_id in doc_options.values():
        selected_doc = db.get_document(selected_document_id)
        if selected_doc:
            default_doc_index = list(doc_options.keys()).index(selected_doc['title'])
        else:
            default_doc_index = 0
    else:
        default_doc_index = 0
    
    selected_doc_name = st.selectbox(
        "Choose a document to chat with",
        options=list(doc_options.keys()),
        index=default_doc_index,
        key="chat_document_selector"
    )
    
    current_document_id = doc_options[selected_doc_name]
    current_document = db.get_document(current_document_id)
    st.session_state.selected_document_id = current_document_id
    
    # Initialize chat session state
    chat_key = f"chat_messages_{current_document_id}"
    if chat_key not in st.session_state:
        st.session_state[chat_key] = []
    
    st.markdown("---")
    
    # Chat settings in sidebar/expander
    with st.expander("‚öôÔ∏è Chat Settings"):
        col1, col2 = st.columns(2)
        
        with col1:
            temperature = st.slider(
                "Temperature",
                min_value=0.0,
                max_value=1.0,
                value=0.7,
                step=0.1,
                help="Higher = more creative, Lower = more focused"
            )
            
            num_chunks = st.slider(
                "Context Chunks",
                min_value=3,
                max_value=10,
                value=5,
                help="Number of relevant chunks to retrieve"
            )
        
        with col2:
            max_tokens = st.slider(
                "Max Response Length",
                min_value=100,
                max_value=2000,
                value=1000,
                step=100,
                help="Maximum tokens in response"
            )
            
            show_sources = st.checkbox(
                "Show Sources",
                value=True,
                help="Display source chunks used for response"
            )
    
    # Action buttons
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        if st.button("üîÑ New Chat", use_container_width=True):
            st.session_state[chat_key] = []
            st.rerun()
    
    with col2:
        if st.button("üíæ Save History", use_container_width=True):
            # Save current chat to database
            if st.session_state[chat_key]:
                for msg in st.session_state[chat_key]:
                    if not msg.get('saved', False):
                        db.add_chat_message(
                            document_id=current_document_id,
                            user_id=user_id,
                            role=msg['role'],
                            message=msg['content']
                        )
                        msg['saved'] = True
                st.success("‚úÖ Chat history saved!")
            else:
                st.info("No messages to save")
    
    with col3:
        if st.button("üìú Load History", use_container_width=True):
            history = db.get_chat_history(current_document_id, limit=50)
            if history:
                st.session_state[chat_key] = [
                    {'role': h['role'], 'content': h['message'], 'saved': True}
                    for h in history
                ]
                st.success(f"‚úÖ Loaded {len(history)} messages")
                st.rerun()
            else:
                st.info("No previous chat history")
    
    with col4:
        if st.button("üóëÔ∏è Clear Chat", use_container_width=True):
            if st.session_state[chat_key]:
                st.session_state.confirm_clear_chat = True
                st.rerun()
            else:
                st.info("Chat is already empty")
    
    # Clear confirmation dialog
    if st.session_state.get('confirm_clear_chat', False):
        st.warning("‚ö†Ô∏è **Clear current chat?** This will only clear the current session, not saved history.")
        col_yes, col_no = st.columns(2)
        with col_yes:
            if st.button("Yes, Clear", type="primary", use_container_width=True):
                st.session_state[chat_key] = []
                st.session_state.confirm_clear_chat = False
                st.rerun()
        with col_no:
            if st.button("Cancel", use_container_width=True):
                st.session_state.confirm_clear_chat = False
                st.rerun()
    
    st.markdown("---")
    
    # Display document info
    st.info(f"üí¨ Chatting with: **{current_document['title']}** ({current_document['chunk_count']} chunks)")
    
    # Chat container
    chat_container = st.container()
    
    with chat_container:
        # Display chat messages
        for message in st.session_state[chat_key]:
            with st.chat_message(message["role"]):
                st.markdown(message["content"])
                
                # Show sources if available and it's an assistant message
                if message["role"] == "assistant" and message.get("sources"):
                    if show_sources and message["sources"]:
                        with st.expander("üìö View Sources", expanded=False):
                            for i, source in enumerate(message["sources"], 1):
                                st.markdown(f"**Source {i}:**")
                                source_text = source.get('text', '')
                                source_metadata = source.get('metadata', {})
                                
                                # Show the text
                                if len(source_text) > 300:
                                    st.text(source_text[:300] + "...")
                                else:
                                    st.text(source_text)
                                
                                # Show metadata
                                if source_metadata:
                                    meta_str = ", ".join([f"{k}: {v}" for k, v in source_metadata.items()])
                                    st.caption(f"üìç {meta_str}")
                                
                                if i < len(message["sources"]):
                                    st.markdown("---")
    
    # Chat input
    if prompt := st.chat_input("Ask a question about the document..."):
        # Add user message to chat
        st.session_state[chat_key].append({"role": "user", "content": prompt, "saved": False})
        
        # Display user message
        with st.chat_message("user"):
            st.markdown(prompt)
        
        # Generate response
        with st.chat_message("assistant"):
            with st.spinner("Thinking..."):
                try:
                    # Initialize RAG system
                    rag = RAGSystem(
                        azure_api_key=settings['azure_api_key'],
                        azure_endpoint=settings['azure_endpoint'],
                        azure_deployment_name=settings['azure_deployment_name'],
                        azure_api_version=settings['azure_api_version'],
                        embedding_model=settings['embedding_model']
                    )
                    
                    # Load FAISS index
                    rag.load_index(current_document['faiss_index_path'])
                    
                    # Prepare chat history for context (last 5 messages)
                    chat_history = []
                    for msg in st.session_state[chat_key][-6:-1]:  # Exclude the current message
                        chat_history.append({
                            "role": msg["role"],
                            "content": msg["content"]
                        })
                    
                    # Get response with RAG
                    response, sources = rag.chat(
                        query=prompt,
                        k=num_chunks,
                        chat_history=chat_history if chat_history else None,
                        temperature=temperature
                    )
                    
                    # Display response
                    st.markdown(response)
                    
                    # Prepare sources for storage
                    sources_for_storage = []
                    if sources:
                        for source in sources:
                            # Handle tuple format (text, metadata, distance)
                            if isinstance(source, tuple) and len(source) >= 2:
                                sources_for_storage.append({
                                    "text": source[0],
                                    "metadata": source[1]
                                })
                    
                    # Show sources if enabled
                    if show_sources and sources_for_storage:
                        with st.expander("üìö View Sources"):
                            for i, source in enumerate(sources_for_storage, 1):
                                st.markdown(f"**Source {i}:**")
                                chunk_text = source.get('text', '')
                                chunk_metadata = source.get('metadata', {})
                                
                                st.text(chunk_text[:300] + "..." if len(chunk_text) > 300 else chunk_text)
                                if chunk_metadata:
                                    st.caption(f"Metadata: {chunk_metadata}")
                                st.markdown("---")
                    
                    # Add assistant response to chat
                    st.session_state[chat_key].append({
                        "role": "assistant",
                        "content": response,
                        "sources": sources_for_storage,
                        "saved": False
                    })
                    
                except Exception as e:
                    error_message = f"Error: {str(e)}"
                    st.error(f"‚ùå Error generating response: {error_message}")
                    
                    # Still add user message even if there's an error
                    # (it's already added above, so we just add error as assistant message)
                    st.session_state[chat_key].append({
                        "role": "assistant",
                        "content": f"I encountered an error: {error_message}",
                        "sources": None,
                        "saved": False
                    })
    
    # Welcome message when chat is empty
    if not st.session_state[chat_key]:
        st.markdown("---")
        st.info("""
        üí° **Ready to chat!** 
        
        Ask questions about the document like:
        - "What are the main topics covered?"
        - "Can you summarize the key points?"
        - "Explain [specific concept] in detail"
        - "What are the important takeaways?"
        """)
    
    # Chat statistics
    if st.session_state[chat_key]:
        st.markdown("---")
        total_messages = len(st.session_state[chat_key])
        user_messages = len([m for m in st.session_state[chat_key] if m['role'] == 'user'])
        assistant_messages = len([m for m in st.session_state[chat_key] if m['role'] == 'assistant'])
        
        col_stat1, col_stat2, col_stat3 = st.columns(3)
        with col_stat1:
            st.metric("Total Messages", total_messages)
        with col_stat2:
            st.metric("Your Questions", user_messages)
        with col_stat3:
            st.metric("AI Responses", assistant_messages)
    
    # Tips
    st.markdown("---")
    st.markdown("### üí° Tips for Better Answers")
    with st.expander("How to ask effective questions"):
        st.markdown("""
        **‚úÖ Good Questions:**
        - "What is the definition of [term]?"
        - "Explain the relationship between [concept A] and [concept B]"
        - "What are the steps in [process]?"
        - "Compare and contrast [X] and [Y]"
        
        **‚ùå Avoid:**
        - Very vague questions without context
        - Questions about topics not in the document
        - Asking for opinions (AI provides factual information from documents)
        
        **üí° Pro Tips:**
        - Be specific about what you want to know
        - Reference specific sections or concepts
        - Ask follow-up questions to dive deeper
        - Adjust temperature for more creative or focused responses
        """)
    
    # Back to dashboard
    st.markdown("---")
    if st.button("‚Üê Back to Dashboard", use_container_width=True):
        navigate_to('dashboard')

#This is pages/dashboard/douments.py
import streamlit as st
from utils.auth import AuthManager
from database.db_manager import DatabaseManager
from utils.document_processor import DocumentProcessor, process_uploaded_file, cleanup_file
from utils.rag_system import RAGSystem
import os
from pathlib import Path


def show_documents_page(db: DatabaseManager, auth: AuthManager, navigate_to):
    """
    Display the documents management page
    
    Args:
        db: DatabaseManager instance
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    # Page header
    st.markdown("""
        <div style='padding: 1rem 0;'>
            <h1 style='color: #1f77b4;'>üìÑ Documents</h1>
            <p style='color: #666; font-size: 1.1rem;'>Upload and manage your study materials</p>
        </div>
    """, unsafe_allow_html=True)
    
    user_id = auth.get_current_user_id()
    
    # Check Azure settings
    if not auth.has_azure_settings():
        st.warning("‚ö†Ô∏è **Azure OpenAI settings not configured**")
        st.info("You need to configure your Azure OpenAI credentials to process documents and use AI features.")
        if st.button("‚öôÔ∏è Go to Settings", type="primary"):
            navigate_to('settings')
        return
    
    # Get user subjects
    subjects = db.get_user_subjects(user_id)
    
    if not subjects:
        st.warning("üìö **No subjects found**")
        st.info("You need to create at least one subject before uploading documents.")
        if st.button("‚ûï Create Subject", type="primary"):
            navigate_to('subjects')
        return
    
    # Subject selector
    st.markdown("### üìö Select Subject")
    
    # Check if a subject is pre-selected (from navigation)
    selected_subject_id = st.session_state.get('selected_subject_id')
    
    # Create subject options
    subject_options = {f"{s['name']}": s['id'] for s in subjects}
    
    # Find index of pre-selected subject
    if selected_subject_id:
        selected_subject = db.get_subject(selected_subject_id)
        if selected_subject:
            default_index = list(subject_options.keys()).index(selected_subject['name'])
        else:
            default_index = 0
    else:
        default_index = 0
    
    selected_subject_name = st.selectbox(
        "Choose a subject to view or add documents",
        options=list(subject_options.keys()),
        index=default_index,
        key="subject_selector"
    )
    
    current_subject_id = subject_options[selected_subject_name]
    current_subject = db.get_subject(current_subject_id)
    
    # Update session state
    st.session_state.selected_subject_id = current_subject_id
    
    st.markdown("---")
    
    # Action buttons
    col1, col2, col3 = st.columns([2, 2, 6])
    
    with col1:
        if st.button("üì§ Upload Document", type="primary", use_container_width=True):
            st.session_state.show_upload_form = True
    
    with col2:
        if st.button("üîÑ Refresh", use_container_width=True):
            st.rerun()
    
    st.markdown("---")
    
    # Upload document form
    if st.session_state.get('show_upload_form', False):
        st.markdown("### üì§ Upload New Document")
        
        st.info(f"üìö Uploading to: **{current_subject['name']}**")
        
        with st.form("upload_document_form", clear_on_submit=True):
            uploaded_file = st.file_uploader(
                "Choose a file",
                type=['pdf', 'docx', 'txt', 'md'],
                help="Supported formats: PDF, DOCX, TXT, MD"
            )
            
            document_title = st.text_input(
                "Document Title (optional)",
                placeholder="Leave blank to use filename",
                help="Custom title for this document"
            )
            
            col_upload, col_cancel = st.columns(2)
            
            with col_upload:
                upload = st.form_submit_button("Upload & Process", type="primary", use_container_width=True)
            
            with col_cancel:
                cancel = st.form_submit_button("Cancel", use_container_width=True)
            
            if cancel:
                st.session_state.show_upload_form = False
                st.rerun()
            
            if upload:
                if not uploaded_file:
                    st.error("‚ö†Ô∏è Please select a file to upload")
                else:
                    # Use filename as title if not provided
                    title = document_title if document_title else uploaded_file.name
                    
                    try:
                        with st.spinner("Uploading file..."):
                            # Save uploaded file
                            file_path, file_type = process_uploaded_file(uploaded_file, "uploads")
                            file_size = os.path.getsize(file_path)
                        
                        # Create document record
                        document_id = db.create_document(
                            subject_id=current_subject_id,
                            user_id=user_id,
                            title=title,
                            file_path=file_path,
                            file_type=file_type,
                            file_size=file_size
                        )
                        
                        if document_id:
                            st.success(f"‚úÖ File uploaded: {title}")
                            
                            # Add processing log
                            db.add_processing_log(document_id, "uploaded", "File uploaded successfully")
                            
                            # Process document
                            with st.spinner("Processing document... This may take a moment."):
                                try:
                                    # Update status
                                    db.update_document_processing(document_id, "processing")
                                    db.add_processing_log(document_id, "processing", "Starting document processing")
                                    
                                    # Initialize processor
                                    processor = DocumentProcessor(chunk_size=1000, chunk_overlap=200)
                                    
                                    # Process document
                                    chunk_texts, chunk_metadata, stats = processor.process_document(file_path)
                                    
                                    st.info(f"üìä Extracted {stats['total_chunks']} chunks from document")
                                    
                                    # Get user settings for RAG
                                    settings = db.get_user_settings(user_id)
                                    
                                    # Initialize RAG system
                                    rag = RAGSystem(
                                        azure_api_key=settings['azure_api_key'],
                                        azure_endpoint=settings['azure_endpoint'],
                                        azure_deployment_name=settings['azure_deployment_name'],
                                        azure_api_version=settings['azure_api_version'],
                                        embedding_model=settings['embedding_model']
                                    )
                                    
                                    # Create FAISS index
                                    rag.create_index(chunk_texts, chunk_metadata)
                                    
                                    # Save index
                                    index_dir = f"data/faiss_indices/user_{user_id}"
                                    os.makedirs(index_dir, exist_ok=True)
                                    index_path = f"{index_dir}/doc_{document_id}"
                                    rag.save_index(index_path)
                                    
                                    # Update document with processing results
                                    db.update_document_processing(
                                        document_id=document_id,
                                        status="completed",
                                        faiss_index_path=index_path,
                                        chunk_count=stats['total_chunks']
                                    )
                                    
                                    db.add_processing_log(
                                        document_id,
                                        "completed",
                                        f"Successfully processed {stats['total_chunks']} chunks"
                                    )
                                    
                                    st.success("‚úÖ Document processed successfully!")
                                    st.balloons()
                                    
                                except Exception as e:
                                    st.error(f"‚ùå Error processing document: {str(e)}")
                                    db.update_document_processing(document_id, "failed")
                                    db.add_processing_log(document_id, "failed", str(e))
                            
                            st.session_state.show_upload_form = False
                            import time
                            time.sleep(2)
                            st.rerun()
                        else:
                            st.error("‚ùå Failed to create document record")
                            cleanup_file(file_path)
                            
                    except Exception as e:
                        st.error(f"‚ùå Error uploading file: {str(e)}")
        
        st.markdown("---")
    
    # Display documents for selected subject
    documents = db.get_subject_documents(current_subject_id)
    
    if documents:
        st.markdown(f"### üìö Documents in {current_subject['name']} ({len(documents)})")
        
        # Search documents
        search_term = st.text_input("üîç Search documents", placeholder="Type to search...")
        
        # Filter documents
        if search_term:
            filtered_docs = [d for d in documents if search_term.lower() in d['title'].lower()]
        else:
            filtered_docs = documents
        
        if not filtered_docs:
            st.info("No documents found matching your search.")
        else:
            # Display documents as cards
            for doc in filtered_docs:
                # Status badge
                status = doc['processing_status']
                if status == 'completed':
                    status_badge = "‚úÖ Ready"
                    status_color = "#4caf50"
                elif status == 'processing':
                    status_badge = "‚è≥ Processing"
                    status_color = "#ff9800"
                elif status == 'failed':
                    status_badge = "‚ùå Failed"
                    status_color = "#f44336"
                else:
                    status_badge = "‚è∏Ô∏è Pending"
                    status_color = "#9e9e9e"
                
                # Document card
                with st.container():
                    st.markdown(f"""
                        <div style='background-color: #f8f9fa; padding: 1.5rem; border-radius: 10px; 
                                    border-left: 5px solid {current_subject['color'] if current_subject.get('color') else '#1f77b4'}; 
                                    margin-bottom: 1rem;'>
                            <div style='display: flex; justify-content: space-between; align-items: start;'>
                                <div>
                                    <h3 style='margin: 0 0 0.5rem 0; color: #333;'>üìÑ {doc['title']}</h3>
                                    <p style='color: #666; font-size: 0.9rem; margin: 0.3rem 0;'>
                                        <strong>Type:</strong> {doc['file_type'].upper()} | 
                                        <strong>Size:</strong> {doc['file_size'] / 1024:.1f} KB | 
                                        <strong>Chunks:</strong> {doc['chunk_count'] if doc['chunk_count'] else 'N/A'}
                                    </p>
                                    <p style='color: #999; font-size: 0.85rem; margin: 0.3rem 0;'>
                                        Uploaded: {doc['upload_date'][:10]}
                                    </p>
                                </div>
                                <div style='background-color: {status_color}; color: white; padding: 0.5rem 1rem; 
                                            border-radius: 5px; font-size: 0.85rem; font-weight: bold;'>
                                    {status_badge}
                                </div>
                            </div>
                        </div>
                    """, unsafe_allow_html=True)
                    
                    # Action buttons
                    col_1, col_2, col_3, col_4, col_5, col_6 = st.columns(6)
                    
                    with col_1:
                        if st.button("üí¨ Chat", key=f"chat_{doc['id']}", 
                                   use_container_width=True, 
                                   disabled=(status != 'completed')):
                            st.session_state.selected_document_id = doc['id']
                            navigate_to('chat')
                    
                    with col_2:
                        if st.button("‚ùì Quiz", key=f"quiz_{doc['id']}", 
                                   use_container_width=True,
                                   disabled=(status != 'completed')):
                            st.session_state.selected_document_id = doc['id']
                            navigate_to('quiz')
                    
                    with col_3:
                        if st.button("üé¥ Cards", key=f"flash_{doc['id']}", 
                                   use_container_width=True,
                                   disabled=(status != 'completed')):
                            st.session_state.selected_document_id = doc['id']
                            navigate_to('flashcard')
                    
                    with col_4:
                        if st.button("üìä Info", key=f"info_{doc['id']}", 
                                   use_container_width=True):
                            st.session_state.viewing_document_id = doc['id']
                            st.rerun()
                    
                    with col_5:
                        if st.button("üîÑ Reprocess", key=f"reprocess_{doc['id']}", 
                                   use_container_width=True,
                                   disabled=(status == 'processing')):
                            st.session_state.reprocessing_document_id = doc['id']
                            st.rerun()
                    
                    with col_6:
                        if st.button("üóëÔ∏è Delete", key=f"delete_{doc['id']}", 
                                   use_container_width=True):
                            st.session_state.deleting_document_id = doc['id']
                            st.rerun()
                    
                    st.markdown("---")
            
            # Document info dialog
            if st.session_state.get('viewing_document_id'):
                viewing_id = st.session_state.viewing_document_id
                doc_info = db.get_document(viewing_id)
                
                if doc_info:
                    st.markdown("---")
                    st.markdown(f"### üìä Document Information: {doc_info['title']}")
                    
                    col_a, col_b = st.columns(2)
                    
                    with col_a:
                        st.write(f"**Title:** {doc_info['title']}")
                        st.write(f"**File Type:** {doc_info['file_type'].upper()}")
                        st.write(f"**File Size:** {doc_info['file_size'] / 1024:.2f} KB")
                        st.write(f"**Upload Date:** {doc_info['upload_date']}")
                    
                    with col_b:
                        st.write(f"**Status:** {doc_info['processing_status']}")
                        st.write(f"**Chunks:** {doc_info['chunk_count'] if doc_info['chunk_count'] else 'N/A'}")
                        st.write(f"**Index Path:** {doc_info['faiss_index_path'] if doc_info['faiss_index_path'] else 'N/A'}")
                    
                    # Processing logs
                    st.markdown("#### üìù Processing Logs")
                    logs = db.get_processing_logs(viewing_id)
                    
                    if logs:
                        for log in logs:
                            st.text(f"[{log['timestamp'][:19]}] {log['status']}: {log['message']}")
                    else:
                        st.info("No processing logs available")
                    
                    if st.button("Close", use_container_width=True):
                        st.session_state.viewing_document_id = None
                        st.rerun()
            
            # Reprocess confirmation
            if st.session_state.get('reprocessing_document_id'):
                st.markdown("---")
                reprocess_id = st.session_state.reprocessing_document_id
                doc_reprocess = db.get_document(reprocess_id)
                
                if doc_reprocess:
                    st.warning(f"### üîÑ Reprocess Document: {doc_reprocess['title']}?")
                    st.info("This will re-extract text and recreate the FAISS index. Existing chat history will be preserved.")
                    
                    col_yes, col_no = st.columns(2)
                    
                    with col_yes:
                        if st.button("Yes, Reprocess", type="primary", use_container_width=True):
                            # Implement reprocessing logic (similar to upload)
                            st.info("Reprocessing... (implement full reprocessing logic)")
                            st.session_state.reprocessing_document_id = None
                            # TODO: Add full reprocessing implementation
                    
                    with col_no:
                        if st.button("Cancel", use_container_width=True):
                            st.session_state.reprocessing_document_id = None
                            st.rerun()
            
            # Delete confirmation
            if st.session_state.get('deleting_document_id'):
                st.markdown("---")
                deleting_id = st.session_state.deleting_document_id
                doc_delete = db.get_document(deleting_id)
                
                if doc_delete:
                    st.error(f"### ‚ö†Ô∏è Delete Document: {doc_delete['title']}?")
                    st.warning("""
                    **Warning:** This will permanently delete:
                    - The document and its file
                    - All associated chat history
                    - All quizzes and flashcards
                    - The FAISS index
                    
                    This action cannot be undone!
                    """)
                    
                    col_yes, col_no = st.columns(2)
                    
                    with col_yes:
                        if st.button("üóëÔ∏è Yes, Delete", type="primary", use_container_width=True):
                            try:
                                # Delete FAISS index files
                                if doc_delete['faiss_index_path']:
                                    cleanup_file(f"{doc_delete['faiss_index_path']}.faiss")
                                    cleanup_file(f"{doc_delete['faiss_index_path']}.pkl")
                                
                                # Delete uploaded file
                                cleanup_file(doc_delete['file_path'])
                                
                                # Delete from database (cascades to related data)
                                db.delete_document(deleting_id)
                                
                                st.success(f"‚úÖ Document '{doc_delete['title']}' deleted successfully!")
                                st.session_state.deleting_document_id = None
                                import time
                                time.sleep(1)
                                st.rerun()
                            except Exception as e:
                                st.error(f"‚ùå Error deleting document: {str(e)}")
                    
                    with col_no:
                        if st.button("Cancel", use_container_width=True):
                            st.session_state.deleting_document_id = None
                            st.rerun()
    else:
        # Empty state
        st.info(f"üìÑ **No documents in {current_subject['name']} yet**")
        st.markdown("""
        Upload your first document to get started! Supported formats:
        - **PDF** (.pdf) - Textbooks, papers, lecture notes
        - **Word** (.docx) - Essays, study guides
        - **Text** (.txt, .md) - Notes, summaries
        """)
        
        if st.button("üì§ Upload First Document", type="primary"):
            st.session_state.show_upload_form = True
            st.rerun()
    
    # Back to dashboard
    st.markdown("---")
    if st.button("‚Üê Back to Dashboard", use_container_width=True):
        navigate_to('dashboard')

#This is pages/dashboard/flashcard.py
import streamlit as st
from utils.auth import AuthManager
from database.db_manager import DatabaseManager
from utils.rag_system import RAGSystem
import json
import re
from datetime import datetime, timedelta
import random


def show_flashcard_page(db: DatabaseManager, auth: AuthManager, navigate_to):
    """
    Display the flashcard page for creating and studying flashcards
    
    Args:
        db: DatabaseManager instance
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    # Page header
    st.markdown("""
        <div style='padding: 1rem 0;'>
            <h1 style='color: #1f77b4;'>üé¥ Flashcards</h1>
            <p style='color: #666; font-size: 1.1rem;'>Create and study with AI-generated flashcards</p>
        </div>
    """, unsafe_allow_html=True)
    
    user_id = auth.get_current_user_id()
    
    # Check Azure settings
    if not auth.has_azure_settings():
        st.warning("‚ö†Ô∏è **Azure OpenAI settings not configured**")
        if st.button("‚öôÔ∏è Go to Settings", type="primary"):
            navigate_to('settings')
        return
    
    # Get user settings
    settings = db.get_user_settings(user_id)
    
    # Get subjects
    subjects = db.get_user_subjects(user_id)
    
    if not subjects:
        st.warning("üìö **No subjects found**")
        if st.button("‚ûï Create Subject", type="primary"):
            navigate_to('subjects')
        return
    
    # Subject selector
    st.markdown("### üìö Select Subject")
    
    selected_subject_id = st.session_state.get('selected_subject_id')
    subject_options = {f"{s['name']}": s['id'] for s in subjects}
    
    if selected_subject_id:
        selected_subject = db.get_subject(selected_subject_id)
        if selected_subject:
            default_index = list(subject_options.keys()).index(selected_subject['name'])
        else:
            default_index = 0
    else:
        default_index = 0
    
    selected_subject_name = st.selectbox(
        "Choose a subject",
        options=list(subject_options.keys()),
        index=default_index,
        key="flashcard_subject_selector"
    )
    
    current_subject_id = subject_options[selected_subject_name]
    st.session_state.selected_subject_id = current_subject_id
    
    # Get documents for subject
    documents = db.get_subject_documents(current_subject_id)
    completed_docs = [d for d in documents if d['processing_status'] == 'completed']
    
    if not completed_docs:
        st.warning(f"üìÑ **No processed documents in this subject**")
        if st.button("üì§ Upload Document", type="primary"):
            navigate_to('documents')
        return
    
    # Document selector
    st.markdown("### üìÑ Select Document")
    
    selected_document_id = st.session_state.get('selected_document_id')
    doc_options = {f"{d['title']}": d['id'] for d in completed_docs}
    
    if selected_document_id and selected_document_id in doc_options.values():
        selected_doc = db.get_document(selected_document_id)
        if selected_doc:
            default_doc_index = list(doc_options.keys()).index(selected_doc['title'])
        else:
            default_doc_index = 0
    else:
        default_doc_index = 0
    
    selected_doc_name = st.selectbox(
        "Choose a document",
        options=list(doc_options.keys()),
        index=default_doc_index,
        key="flashcard_document_selector"
    )
    
    current_document_id = doc_options[selected_doc_name]
    current_document = db.get_document(current_document_id)
    st.session_state.selected_document_id = current_document_id
    
    st.markdown("---")
    
    # Tabs for different sections
    tab1, tab2, tab3 = st.tabs(["üé¥ Generate Flashcards", "üìö Study", "üìä Statistics"])
    
    # ==================== TAB 1: Generate Flashcards ====================
    with tab1:
        st.markdown("### üé¥ Create New Flashcard Set")
        
        with st.form("flashcard_generation_form"):
            col1, col2 = st.columns(2)
            
            with col1:
                num_cards = st.slider(
                    "Number of Flashcards",
                    min_value=5,
                    max_value=50,
                    value=10,
                    help="How many flashcards to generate"
                )
            
            with col2:
                set_title = st.text_input(
                    "Set Title (optional)",
                    placeholder="Leave blank for auto-generated title",
                    help="Custom name for this flashcard set"
                )
            
            topic_focus = st.text_input(
                "Topic Focus (optional)",
                placeholder="e.g., Chapter 3, Key Terms, Important Concepts",
                help="Focus on a specific topic"
            )
            
            generate = st.form_submit_button("üé≤ Generate Flashcards", type="primary", use_container_width=True)
            
            if generate:
                with st.spinner(f"Generating {num_cards} flashcards... This may take a moment."):
                    try:
                        # Initialize RAG system
                        rag = RAGSystem(
                            azure_api_key=settings['azure_api_key'],
                            azure_endpoint=settings['azure_endpoint'],
                            azure_deployment_name=settings['azure_deployment_name'],
                            azure_api_version=settings['azure_api_version']
                        )
                        
                        # Load FAISS index
                        rag.load_index(current_document['faiss_index_path'])
                        
                        # Generate flashcards
                        flashcards_json = rag.generate_flashcards(
                            num_cards=num_cards,
                            topic=topic_focus if topic_focus else None
                        )
                        
                        # Parse JSON response
                        try:
                            # Try to extract JSON from response
                            json_match = re.search(r'\[.*\]', flashcards_json, re.DOTALL)
                            if json_match:
                                cards_data = json.loads(json_match.group())
                            else:
                                cards_data = json.loads(flashcards_json)
                        except json.JSONDecodeError:
                            st.error("Failed to parse flashcards. Please try again.")
                            cards_data = None
                        
                        if cards_data:
                            # Create flashcard set in database
                            title = set_title if set_title else f"Flashcards - {current_document['title']} ({datetime.now().strftime('%Y-%m-%d %H:%M')})"
                            set_id = db.create_flashcard_set(current_document_id, user_id, title)
                            
                            # Add flashcards to database
                            for card in cards_data:
                                db.add_flashcard(
                                    flashcard_set_id=set_id,
                                    front=card.get('front', ''),
                                    back=card.get('back', '')
                                )
                            
                            st.success(f"‚úÖ Flashcard set '{title}' created with {len(cards_data)} cards!")
                            st.balloons()
                            
                            import time
                            time.sleep(1)
                            st.rerun()
                            
                    except Exception as e:
                        st.error(f"‚ùå Error generating flashcards: {str(e)}")
    
    # ==================== TAB 2: Study ====================
    with tab2:
        st.markdown("### üìö Study Flashcards")
        
        # Get flashcard sets for this document
        flashcard_sets = db.get_document_flashcard_sets(current_document_id)
        
        if flashcard_sets:
            # Select flashcard set
            set_options = {f"{s['title']} ({s['created_at'][:10]})": s['id'] for s in flashcard_sets}
            
            selected_set_name = st.selectbox(
                "Choose a flashcard set",
                options=list(set_options.keys()),
                key="study_set_selector"
            )
            
            selected_set_id = set_options[selected_set_name]
            
            # Get flashcards in this set
            flashcards = db.get_flashcards(selected_set_id)
            
            if flashcards:
                st.info(f"üìö This set has **{len(flashcards)}** flashcards")
                
                # Study mode selector
                study_mode = st.radio(
                    "Study Mode",
                    options=["Sequential", "Random", "Review Difficult"],
                    horizontal=True,
                    help="Sequential: In order, Random: Shuffled, Review Difficult: Focus on cards you marked as difficult"
                )
                
                if st.button("‚ñ∂Ô∏è Start Studying", type="primary", use_container_width=True):
                    # Initialize study session
                    st.session_state.studying = True
                    st.session_state.current_set_id = selected_set_id
                    st.session_state.study_mode = study_mode
                    st.session_state.current_card_index = 0
                    st.session_state.show_answer = False
                    st.session_state.cards_mastered = 0
                    st.session_state.cards_difficult = 0
                    
                    # Prepare card order
                    if study_mode == "Random":
                        st.session_state.card_order = random.sample(range(len(flashcards)), len(flashcards))
                    else:
                        st.session_state.card_order = list(range(len(flashcards)))
                    
                    st.rerun()
                
                # Study session
                if st.session_state.get('studying', False):
                    st.markdown("---")
                    
                    # Get current card
                    card_order = st.session_state.card_order
                    card_index = st.session_state.current_card_index
                    
                    if card_index < len(card_order):
                        current_card = flashcards[card_order[card_index]]
                        
                        # Progress
                        progress = (card_index + 1) / len(flashcards)
                        st.progress(progress)
                        st.markdown(f"**Card {card_index + 1} of {len(flashcards)}**")
                        
                        # Card display
                        if not st.session_state.get('show_answer', False):
                            # Show front
                            st.markdown(f"""
                                <div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                                            padding: 3rem; border-radius: 15px; text-align: center; 
                                            min-height: 250px; display: flex; align-items: center; 
                                            justify-content: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);'>
                                    <div>
                                        <p style='color: #fff; font-size: 0.9rem; margin-bottom: 1rem; 
                                                  opacity: 0.8; text-transform: uppercase; letter-spacing: 2px;'>
                                            Question
                                        </p>
                                        <h2 style='color: white; margin: 0; font-size: 1.8rem; line-height: 1.4;'>
                                            {current_card['front']}
                                        </h2>
                                    </div>
                                </div>
                            """, unsafe_allow_html=True)
                            
                            st.markdown("")
                            if st.button("üîÑ Show Answer", use_container_width=True, type="primary"):
                                st.session_state.show_answer = True
                                st.rerun()
                        else:
                            # Show back
                            st.markdown(f"""
                                <div style='background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); 
                                            padding: 3rem; border-radius: 15px; text-align: center; 
                                            min-height: 250px; display: flex; align-items: center; 
                                            justify-content: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);'>
                                    <div>
                                        <p style='color: #fff; font-size: 0.9rem; margin-bottom: 1rem; 
                                                  opacity: 0.8; text-transform: uppercase; letter-spacing: 2px;'>
                                            Answer
                                        </p>
                                        <h2 style='color: white; margin: 0; font-size: 1.8rem; line-height: 1.4;'>
                                            {current_card['back']}
                                        </h2>
                                    </div>
                                </div>
                            """, unsafe_allow_html=True)
                            
                            st.markdown("### How well did you know this?")
                            
                            col1, col2, col3 = st.columns(3)
                            
                            with col1:
                                if st.button("üò∞ Hard", use_container_width=True):
                                    # Record as difficult
                                    db.add_flashcard_review(
                                        flashcard_item_id=current_card['id'],
                                        user_id=user_id,
                                        difficulty=1,
                                        next_review_date=(datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d')
                                    )
                                    st.session_state.cards_difficult += 1
                                    st.session_state.current_card_index += 1
                                    st.session_state.show_answer = False
                                    st.rerun()
                            
                            with col2:
                                if st.button("ü§î Medium", use_container_width=True):
                                    # Record as medium
                                    db.add_flashcard_review(
                                        flashcard_item_id=current_card['id'],
                                        user_id=user_id,
                                        difficulty=3,
                                        next_review_date=(datetime.now() + timedelta(days=3)).strftime('%Y-%m-%d')
                                    )
                                    st.session_state.current_card_index += 1
                                    st.session_state.show_answer = False
                                    st.rerun()
                            
                            with col3:
                                if st.button("‚úÖ Easy", use_container_width=True):
                                    # Record as mastered
                                    db.add_flashcard_review(
                                        flashcard_item_id=current_card['id'],
                                        user_id=user_id,
                                        difficulty=5,
                                        next_review_date=(datetime.now() + timedelta(days=7)).strftime('%Y-%m-%d')
                                    )
                                    st.session_state.cards_mastered += 1
                                    st.session_state.current_card_index += 1
                                    st.session_state.show_answer = False
                                    st.rerun()
                        
                        # Navigation
                        st.markdown("---")
                        col_nav1, col_nav2 = st.columns(2)
                        
                        with col_nav1:
                            if st.button("‚è∏Ô∏è Pause Study Session", use_container_width=True):
                                st.session_state.studying = False
                                st.rerun()
                        
                        with col_nav2:
                            if card_index > 0:
                                if st.button("‚¨ÖÔ∏è Previous Card", use_container_width=True):
                                    st.session_state.current_card_index -= 1
                                    st.session_state.show_answer = False
                                    st.rerun()
                    else:
                        # Study session complete
                        st.markdown("---")
                        st.success("üéâ **Study Session Complete!**")
                        
                        st.markdown(f"""
                            <div style='background-color: #e8f5e9; padding: 2rem; border-radius: 10px; text-align: center;'>
                                <h2 style='color: #2e7d32; margin-bottom: 1rem;'>Great Job! üåü</h2>
                                <p style='font-size: 1.2rem; margin: 0.5rem 0;'>
                                    You reviewed <strong>{len(flashcards)}</strong> flashcards
                                </p>
                                <p style='font-size: 1rem; color: #666;'>
                                    ‚úÖ Mastered: {st.session_state.cards_mastered} | 
                                    üò∞ Need Review: {st.session_state.cards_difficult}
                                </p>
                            </div>
                        """, unsafe_allow_html=True)
                        
                        col_a, col_b = st.columns(2)
                        
                        with col_a:
                            if st.button("üîÑ Study Again", type="primary", use_container_width=True):
                                st.session_state.current_card_index = 0
                                st.session_state.show_answer = False
                                st.session_state.cards_mastered = 0
                                st.session_state.cards_difficult = 0
                                st.rerun()
                        
                        with col_b:
                            if st.button("‚úì Finish", use_container_width=True):
                                st.session_state.studying = False
                                st.rerun()
            else:
                st.info("This set has no flashcards.")
        else:
            st.info("üìù No flashcard sets yet. Generate your first set!")
    
    # ==================== TAB 3: Statistics ====================
    with tab3:
        st.markdown("### üìä Flashcard Statistics")
        
        all_sets = db.get_document_flashcard_sets(current_document_id)
        
        if all_sets:
            total_sets = len(all_sets)
            total_cards = sum(len(db.get_flashcards(s['id'])) for s in all_sets)
            
            # Display metrics
            col1, col2 = st.columns(2)
            
            with col1:
                st.metric("Total Sets", total_sets)
            with col2:
                st.metric("Total Flashcards", total_cards)
            
            st.markdown("---")
            
            # List all sets with stats
            st.markdown("### üìö Your Flashcard Sets")
            
            for fset in all_sets:
                cards = db.get_flashcards(fset['id'])
                
                with st.expander(f"üé¥ {fset['title']}", expanded=False):
                    col_a, col_b = st.columns(2)
                    
                    with col_a:
                        st.write(f"**Created:** {fset['created_at'][:10]}")
                        st.write(f"**Cards:** {len(cards)}")
                    
                    with col_b:
                        if st.button("üóëÔ∏è Delete Set", key=f"delete_set_{fset['id']}", use_container_width=True):
                            st.session_state.deleting_set_id = fset['id']
                            st.rerun()
            
            # Delete confirmation
            if st.session_state.get('deleting_set_id'):
                st.markdown("---")
                st.error("‚ö†Ô∏è **Delete this flashcard set?** This action cannot be undone.")
                
                col_yes, col_no = st.columns(2)
                
                with col_yes:
                    if st.button("Yes, Delete", type="primary", use_container_width=True):
                        # Delete set (will cascade to cards and reviews)
                        # Note: Need to add delete_flashcard_set method to db_manager
                        try:
                            # For now, this is a placeholder
                            # db.delete_flashcard_set(st.session_state.deleting_set_id)
                            st.success("Set deleted successfully!")
                            st.session_state.deleting_set_id = None
                            st.rerun()
                        except:
                            st.error("Delete functionality needs to be implemented in db_manager")
                
                with col_no:
                    if st.button("Cancel", use_container_width=True):
                        st.session_state.deleting_set_id = None
                        st.rerun()
        else:
            st.info("üìä No statistics yet. Create some flashcard sets to see your progress!")
    
    # Back to dashboard
    st.markdown("---")
    if st.button("‚Üê Back to Dashboard", use_container_width=True):
        navigate_to('dashboard')



#This is pages/dashboard/main.py

import streamlit as st
from utils.auth import AuthManager
from database.db_manager import DatabaseManager
from datetime import datetime, timedelta


def show_dashboard_page(db: DatabaseManager, auth: AuthManager, navigate_to):
    """
    Display the main dashboard/overview page
    
    Args:
        db: DatabaseManager instance
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    # Page header
    st.markdown(f"""
        <div style='padding: 1rem 0;'>
            <h1 style='color: #1f77b4;'>üìä Dashboard</h1>
            <p style='color: #666; font-size: 1.1rem;'>Welcome back, <strong>{auth.get_current_username()}</strong>!</p>
        </div>
    """, unsafe_allow_html=True)
    
    user_id = auth.get_current_user_id()
    
    # Check if user has configured Azure settings
    settings = auth.get_user_settings()
    
    if not auth.has_azure_settings():
        st.warning("‚ö†Ô∏è **Action Required: Configure Azure OpenAI Settings**")
        st.info("""
        To start using the AI features, you need to add your Azure OpenAI credentials.
        
        **You'll need:**
        - Azure OpenAI API Key
        - Azure OpenAI Endpoint URL
        - Deployment Name
        - API Version
        """)
        
        if st.button("‚öôÔ∏è Go to Settings", type="primary"):
            navigate_to('settings')
        
        st.markdown("---")
    
    # Statistics cards
    st.markdown("### üìà Your Study Statistics")
    
    # Get statistics
    subjects = db.get_user_subjects(user_id)
    total_subjects = len(subjects)
    
    # Count total documents
    total_documents = 0
    for subject in subjects:
        documents = db.get_subject_documents(subject['id'])
        total_documents += len(documents)
    
    # Count total tasks
    all_tasks = db.get_user_tasks(user_id)
    pending_tasks = len([t for t in all_tasks if t['status'] == 'pending'])
    completed_tasks = len([t for t in all_tasks if t['status'] == 'completed'])
    
    # Display stats in columns
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown(f"""
            <div style='background-color: #e3f2fd; padding: 1.5rem; border-radius: 10px; text-align: center;'>
                <h2 style='color: #1976d2; margin: 0; font-size: 2.5rem;'>{total_subjects}</h2>
                <p style='color: #666; margin: 0.5rem 0 0 0;'>Subjects</p>
            </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
            <div style='background-color: #f3e5f5; padding: 1.5rem; border-radius: 10px; text-align: center;'>
                <h2 style='color: #7b1fa2; margin: 0; font-size: 2.5rem;'>{total_documents}</h2>
                <p style='color: #666; margin: 0.5rem 0 0 0;'>Documents</p>
            </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
            <div style='background-color: #fff3e0; padding: 1.5rem; border-radius: 10px; text-align: center;'>
                <h2 style='color: #f57c00; margin: 0; font-size: 2.5rem;'>{pending_tasks}</h2>
                <p style='color: #666; margin: 0.5rem 0 0 0;'>Pending Tasks</p>
            </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown(f"""
            <div style='background-color: #e8f5e9; padding: 1.5rem; border-radius: 10px; text-align: center;'>
                <h2 style='color: #388e3c; margin: 0; font-size: 2.5rem;'>{completed_tasks}</h2>
                <p style='color: #666; margin: 0.5rem 0 0 0;'>Completed Tasks</p>
            </div>
        """, unsafe_allow_html=True)
    
    st.markdown("---")
    
    # Quick actions
    st.markdown("### ‚ö° Quick Actions")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        if st.button("‚ûï Add Subject", use_container_width=True, type="primary"):
            navigate_to('subjects')
    
    with col2:
        if st.button("üìÑ Upload Document", use_container_width=True, type="primary"):
            navigate_to('documents')
    
    with col3:
        if st.button("üí¨ Start Chatting", use_container_width=True, type="primary"):
            navigate_to('chat')
    
    with col4:
        if st.button("üìÖ Add Task", use_container_width=True, type="primary"):
            navigate_to('planner')
    
    st.markdown("---")
    
    # Two column layout for subjects and tasks
    col_left, col_right = st.columns([3, 2])
    
    with col_left:
        # Recent subjects
        st.markdown("### üìö Your Subjects")
        
        if subjects:
            for subject in subjects[:5]:  # Show up to 5 subjects
                with st.expander(f"üìñ {subject['name']}", expanded=False):
                    if subject['description']:
                        st.write(subject['description'])
                    else:
                        st.write("*No description*")
                    
                    # Get document count for this subject
                    docs = db.get_subject_documents(subject['id'])
                    st.write(f"**Documents:** {len(docs)}")
                    
                    # Action buttons
                    col_a, col_b, col_c = st.columns(3)
                    with col_a:
                        if st.button("View", key=f"view_subject_{subject['id']}", use_container_width=True):
                            st.session_state.selected_subject_id = subject['id']
                            navigate_to('documents')
                    with col_b:
                        if st.button("Chat", key=f"chat_subject_{subject['id']}", use_container_width=True):
                            st.session_state.selected_subject_id = subject['id']
                            navigate_to('chat')
                    with col_c:
                        if st.button("Quiz", key=f"quiz_subject_{subject['id']}", use_container_width=True):
                            st.session_state.selected_subject_id = subject['id']
                            navigate_to('quiz')
            
            if len(subjects) > 5:
                st.info(f"Showing 5 of {len(subjects)} subjects. View all in the Subjects page.")
                if st.button("View All Subjects"):
                    navigate_to('subjects')
        else:
            st.info("No subjects yet. Create your first subject to get started!")
            if st.button("Create First Subject", type="primary"):
                navigate_to('subjects')
    
    with col_right:
        # Upcoming tasks
        st.markdown("### üìÖ Upcoming Tasks")
        
        # Get tasks due in the next 7 days
        today = datetime.now().date()
        upcoming_tasks = []
        
        for task in all_tasks:
            if task['status'] != 'completed' and task['due_date']:
                try:
                    due_date = datetime.strptime(task['due_date'], '%Y-%m-%d').date()
                    if due_date >= today and due_date <= today + timedelta(days=7):
                        upcoming_tasks.append(task)
                except:
                    pass
        
        # Sort by due date
        upcoming_tasks.sort(key=lambda x: x['due_date'])
        
        if upcoming_tasks:
            for task in upcoming_tasks[:5]:  # Show up to 5 tasks
                due_date = datetime.strptime(task['due_date'], '%Y-%m-%d').date()
                days_until = (due_date - today).days
                
                # Color code by urgency
                if days_until == 0:
                    urgency_color = "#f44336"
                    urgency_text = "üìå Due Today!"
                elif days_until == 1:
                    urgency_color = "#ff9800"
                    urgency_text = "‚ö†Ô∏è Due Tomorrow"
                else:
                    urgency_color = "#4caf50"
                    urgency_text = f"üìÜ Due in {days_until} days"
                
                st.markdown(f"""
                    <div style='background-color: #f5f5f5; padding: 1rem; border-radius: 8px; 
                                margin-bottom: 0.5rem; border-left: 4px solid {urgency_color};'>
                        <p style='margin: 0; font-weight: bold;'>{task['title']}</p>
                        <p style='margin: 0.5rem 0 0 0; font-size: 0.9rem; color: {urgency_color};'>
                            {urgency_text}
                        </p>
                    </div>
                """, unsafe_allow_html=True)
            
            st.markdown("")
            if st.button("View All Tasks", use_container_width=True):
                navigate_to('planner')
        else:
            st.info("No upcoming tasks in the next 7 days.")
            if st.button("Create a Task", type="primary", use_container_width=True):
                navigate_to('planner')
        
        # Pending tasks summary
        if pending_tasks > 0:
            st.markdown("---")
            st.warning(f"‚è≥ You have **{pending_tasks}** pending task(s)")
    
    st.markdown("---")
    
    # Activity tips
    st.markdown("### üí° Study Tips")
    
    tips = [
        "üìö Review your flashcards regularly to improve retention",
        "‚ùì Take quizzes to test your understanding",
        "üí¨ Ask questions about concepts you find difficult",
        "üìÖ Set realistic deadlines for your study tasks",
        "üéØ Focus on one subject at a time for better concentration",
        "üîÑ Use spaced repetition for long-term memory",
        "‚úçÔ∏è Take breaks every 25-30 minutes (Pomodoro technique)",
        "üé® Use the AI to generate different types of study materials"
    ]
    
    import random
    daily_tip = random.choice(tips)
    
    st.info(f"**Tip of the day:** {daily_tip}")
    
    # Footer stats
    st.markdown("---")
    st.markdown(f"""
        <div style='text-align: center; color: #666; padding: 1rem 0;'>
            <p style='margin: 0;'>
                Account created: {auth.get_current_user()['created_at'][:10]} | 
                Last login: {auth.get_current_user()['last_login'][:10] if auth.get_current_user()['last_login'] else 'First time'}
            </p>
        </div>
    """, unsafe_allow_html=True)

#This is pages/dashboard/planner.py

import streamlit as st
from utils.auth import AuthManager
from database.db_manager import DatabaseManager
from datetime import datetime, timedelta


def show_planner_page(db: DatabaseManager, auth: AuthManager, navigate_to):
    """
    Display the study planner page
    
    Args:
        db: DatabaseManager instance
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    # Page header
    st.markdown("""
        <div style='padding: 1rem 0;'>
            <h1 style='color: #1f77b4;'>üìÖ Study Planner</h1>
            <p style='color: #666; font-size: 1.1rem;'>Organize your study tasks and deadlines</p>
        </div>
    """, unsafe_allow_html=True)
    
    user_id = auth.get_current_user_id()
    
    # Get subjects for linking tasks
    subjects = db.get_user_subjects(user_id)
    
    # Action buttons
    col1, col2, col3 = st.columns([2, 2, 6])
    
    with col1:
        if st.button("‚ûï Add Task", type="primary", use_container_width=True):
            st.session_state.show_add_task = True
    
    with col2:
        if st.button("üîÑ Refresh", use_container_width=True):
            st.rerun()
    
    st.markdown("---")
    
    # Add task form
    if st.session_state.get('show_add_task', False):
        st.markdown("### ‚ûï Add New Task")
        
        with st.form("add_task_form", clear_on_submit=True):
            task_title = st.text_input(
                "Task Title *",
                placeholder="e.g., Study Chapter 5, Complete Assignment",
                max_chars=200
            )
            
            task_description = st.text_area(
                "Description (optional)",
                placeholder="Add details about this task...",
                max_chars=500,
                height=100
            )
            
            col_a, col_b, col_c = st.columns(3)
            
            with col_a:
                # Subject selector (optional)
                subject_options = ["None"] + [s['name'] for s in subjects]
                selected_subject = st.selectbox(
                    "Link to Subject (optional)",
                    options=subject_options
                )
            
            with col_b:
                due_date = st.date_input(
                    "Due Date",
                    value=datetime.now().date() + timedelta(days=7),
                    min_value=datetime.now().date()
                )
            
            with col_c:
                priority = st.selectbox(
                    "Priority",
                    options=["low", "medium", "high"],
                    index=1
                )
            
            col_submit, col_cancel = st.columns(2)
            
            with col_submit:
                submit = st.form_submit_button("Add Task", type="primary", use_container_width=True)
            
            with col_cancel:
                cancel = st.form_submit_button("Cancel", use_container_width=True)
            
            if submit:
                if not task_title:
                    st.error("‚ö†Ô∏è Please enter a task title")
                else:
                    # Get subject_id if selected
                    subject_id = None
                    if selected_subject != "None":
                        subject_id = next((s['id'] for s in subjects if s['name'] == selected_subject), None)
                    
                    try:
                        task_id = db.create_task(
                            user_id=user_id,
                            title=task_title,
                            description=task_description,
                            due_date=due_date.strftime('%Y-%m-%d'),
                            priority=priority,
                            subject_id=subject_id
                        )
                        
                        if task_id:
                            st.success(f"‚úÖ Task '{task_title}' created successfully!")
                            st.session_state.show_add_task = False
                            import time
                            time.sleep(1)
                            st.rerun()
                        else:
                            st.error("‚ùå Failed to create task")
                    except Exception as e:
                        st.error(f"‚ùå Error: {str(e)}")
            
            if cancel:
                st.session_state.show_add_task = False
                st.rerun()
        
        st.markdown("---")
    
    # Tabs for different views
    tab1, tab2, tab3, tab4 = st.tabs(["üìã All Tasks", "‚è∞ Upcoming", "‚úÖ Completed", "üìä Statistics"])
    
    # ==================== TAB 1: All Tasks ====================
    with tab1:
        st.markdown("### üìã All Tasks")
        
        # Filter options
        col_filter1, col_filter2 = st.columns(2)
        
        with col_filter1:
            status_filter = st.selectbox(
                "Filter by Status",
                options=["all", "pending", "in_progress", "completed"],
                format_func=lambda x: x.replace("_", " ").title(),
                key="all_status_filter"
            )
        
        with col_filter2:
            priority_filter = st.selectbox(
                "Filter by Priority",
                options=["all", "low", "medium", "high"],
                format_func=lambda x: x.title(),
                key="all_priority_filter"
            )
        
        # Get tasks
        if status_filter == "all":
            tasks = db.get_user_tasks(user_id)
        else:
            tasks = db.get_user_tasks(user_id, status=status_filter)
        
        # Apply priority filter
        if priority_filter != "all":
            tasks = [t for t in tasks if t['priority'] == priority_filter]
        
        if tasks:
            # Sort by due date
            tasks.sort(key=lambda x: x['due_date'] if x['due_date'] else '9999-12-31')
            
            for task in tasks:
                # Priority colors
                priority_colors = {
                    'low': '#4caf50',
                    'medium': '#ff9800',
                    'high': '#f44336'
                }
                priority_color = priority_colors.get(task['priority'], '#9e9e9e')
                
                # Status colors
                status_colors = {
                    'pending': '#2196f3',
                    'in_progress': '#ff9800',
                    'completed': '#4caf50'
                }
                status_color = status_colors.get(task['status'], '#9e9e9e')
                
                # Calculate days until due
                if task['due_date']:
                    due_date = datetime.strptime(task['due_date'], '%Y-%m-%d').date()
                    today = datetime.now().date()
                    days_until = (due_date - today).days
                    
                    if days_until < 0:
                        due_text = f"‚ö†Ô∏è Overdue by {abs(days_until)} days"
                        due_color = "#f44336"
                    elif days_until == 0:
                        due_text = "üìå Due Today!"
                        due_color = "#f44336"
                    elif days_until == 1:
                        due_text = "‚ö†Ô∏è Due Tomorrow"
                        due_color = "#ff9800"
                    else:
                        due_text = f"üìÜ Due in {days_until} days"
                        due_color = "#666"
                else:
                    due_text = "No due date"
                    due_color = "#999"
                
                # Get subject name if linked
                subject_name = ""
                if task['subject_id']:
                    subject = next((s for s in subjects if s['id'] == task['subject_id']), None)
                    if subject:
                        subject_name = f"üìö {subject['name']}"
                
                # Task card
                st.markdown(f"""
                    <div style='background-color: #f8f9fa; padding: 1.5rem; border-radius: 10px; 
                                border-left: 5px solid {priority_color}; margin-bottom: 1rem;'>
                        <div style='display: flex; justify-content: space-between; align-items: start;'>
                            <div style='flex: 1;'>
                                <h3 style='margin: 0 0 0.5rem 0; color: #333;'>{task['title']}</h3>
                                <p style='color: #666; font-size: 0.9rem; margin: 0.3rem 0;'>
                                    {task['description'] if task['description'] else '<em>No description</em>'}
                                </p>
                                <p style='color: {due_color}; font-size: 0.9rem; margin: 0.5rem 0 0 0; font-weight: 500;'>
                                    {due_text}
                                </p>
                                {f'<p style="color: #888; font-size: 0.85rem; margin: 0.3rem 0 0 0;">{subject_name}</p>' if subject_name else ''}
                            </div>
                            <div style='display: flex; gap: 0.5rem; align-items: center;'>
                                <span style='background-color: {priority_color}; color: white; padding: 0.3rem 0.8rem; 
                                            border-radius: 15px; font-size: 0.8rem; font-weight: bold;'>
                                    {task['priority'].upper()}
                                </span>
                                <span style='background-color: {status_color}; color: white; padding: 0.3rem 0.8rem; 
                                            border-radius: 15px; font-size: 0.8rem;'>
                                    {task['status'].replace('_', ' ').title()}
                                </span>
                            </div>
                        </div>
                    </div>
                """, unsafe_allow_html=True)
                
                # Action buttons
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    if task['status'] != 'completed':
                        if st.button("‚úÖ Complete", key=f"complete_{task['id']}", use_container_width=True):
                            db.update_task_status(task['id'], 'completed')
                            st.success("Task completed!")
                            st.rerun()
                
                with col2:
                    if task['status'] == 'pending':
                        if st.button("‚ñ∂Ô∏è Start", key=f"start_{task['id']}", use_container_width=True):
                            db.update_task_status(task['id'], 'in_progress')
                            st.rerun()
                
                with col3:
                    if st.button("‚úèÔ∏è Edit", key=f"edit_{task['id']}", use_container_width=True):
                        st.session_state.editing_task_id = task['id']
                        st.rerun()
                
                with col4:
                    if st.button("üóëÔ∏è Delete", key=f"delete_{task['id']}", use_container_width=True):
                        st.session_state.deleting_task_id = task['id']
                        st.rerun()
                
                st.markdown("---")
            
            # Edit task dialog
            if st.session_state.get('editing_task_id'):
                st.markdown("---")
                editing_id = st.session_state.editing_task_id
                task_to_edit = next((t for t in tasks if t['id'] == editing_id), None)
                
                if task_to_edit:
                    st.markdown(f"### ‚úèÔ∏è Edit Task: {task_to_edit['title']}")
                    
                    with st.form("edit_task_form"):
                        edit_title = st.text_input("Title *", value=task_to_edit['title'])
                        edit_description = st.text_area(
                            "Description", 
                            value=task_to_edit['description'] if task_to_edit['description'] else ""
                        )
                        
                        col_a, col_b, col_c = st.columns(3)
                        
                        with col_a:
                            edit_due_date = st.date_input(
                                "Due Date",
                                value=datetime.strptime(task_to_edit['due_date'], '%Y-%m-%d').date() if task_to_edit['due_date'] else datetime.now().date()
                            )
                        
                        with col_b:
                            edit_priority = st.selectbox(
                                "Priority",
                                options=["low", "medium", "high"],
                                index=["low", "medium", "high"].index(task_to_edit['priority'])
                            )
                        
                        with col_c:
                            edit_status = st.selectbox(
                                "Status",
                                options=["pending", "in_progress", "completed"],
                                index=["pending", "in_progress", "completed"].index(task_to_edit['status'])
                            )
                        
                        col_save, col_cancel = st.columns(2)
                        
                        with col_save:
                            if st.form_submit_button("Save Changes", type="primary", use_container_width=True):
                                # Update task (need to add update method to db_manager)
                                st.info("Update functionality needs to be implemented in db_manager")
                                st.session_state.editing_task_id = None
                                st.rerun()
                        
                        with col_cancel:
                            if st.form_submit_button("Cancel", use_container_width=True):
                                st.session_state.editing_task_id = None
                                st.rerun()
            
            # Delete confirmation
            if st.session_state.get('deleting_task_id'):
                st.markdown("---")
                deleting_id = st.session_state.deleting_task_id
                task_to_delete = next((t for t in tasks if t['id'] == deleting_id), None)
                
                if task_to_delete:
                    st.error(f"### ‚ö†Ô∏è Delete Task: {task_to_delete['title']}?")
                    st.warning("This action cannot be undone!")
                    
                    col_yes, col_no = st.columns(2)
                    
                    with col_yes:
                        if st.button("üóëÔ∏è Yes, Delete", type="primary", use_container_width=True):
                            try:
                                db.delete_task(deleting_id)
                                st.success("Task deleted successfully!")
                                st.session_state.deleting_task_id = None
                                import time
                                time.sleep(1)
                                st.rerun()
                            except Exception as e:
                                st.error(f"Error: {str(e)}")
                    
                    with col_no:
                        if st.button("Cancel", use_container_width=True):
                            st.session_state.deleting_task_id = None
                            st.rerun()
        else:
            st.info("üìù No tasks found. Create your first task to get started!")
    
    # ==================== TAB 2: Upcoming ====================
    with tab2:
        st.markdown("### ‚è∞ Upcoming Tasks (Next 7 Days)")
        
        all_tasks = db.get_user_tasks(user_id)
        today = datetime.now().date()
        week_later = today + timedelta(days=7)
        
        upcoming_tasks = []
        for task in all_tasks:
            if task['status'] != 'completed' and task['due_date']:
                due_date = datetime.strptime(task['due_date'], '%Y-%m-%d').date()
                if today <= due_date <= week_later:
                    upcoming_tasks.append(task)
        
        if upcoming_tasks:
            # Sort by due date
            upcoming_tasks.sort(key=lambda x: x['due_date'])
            
            for task in upcoming_tasks:
                due_date = datetime.strptime(task['due_date'], '%Y-%m-%d').date()
                days_until = (due_date - today).days
                
                if days_until == 0:
                    urgency = "üî¥ DUE TODAY!"
                    color = "#f44336"
                elif days_until == 1:
                    urgency = "üü† Due Tomorrow"
                    color = "#ff9800"
                else:
                    urgency = f"üü¢ Due in {days_until} days"
                    color = "#4caf50"
                
                st.markdown(f"""
                    <div style='background-color: #f5f5f5; padding: 1rem; border-radius: 8px; 
                                margin-bottom: 0.5rem; border-left: 4px solid {color};'>
                        <p style='margin: 0; font-weight: bold; font-size: 1.1rem;'>{task['title']}</p>
                        <p style='margin: 0.5rem 0 0 0; color: {color}; font-weight: 500;'>{urgency}</p>
                    </div>
                """, unsafe_allow_html=True)
            
            st.markdown("")
        else:
            st.info("üéâ No upcoming tasks in the next 7 days!")
    
    # ==================== TAB 3: Completed ====================
    with tab3:
        st.markdown("### ‚úÖ Completed Tasks")
        
        completed_tasks = db.get_user_tasks(user_id, status='completed')
        
        if completed_tasks:
            # Sort by completion date (most recent first)
            completed_tasks.sort(key=lambda x: x['completed_at'] if x['completed_at'] else '', reverse=True)
            
            for task in completed_tasks:
                completed_date = task['completed_at'][:10] if task['completed_at'] else 'Unknown'
                
                with st.expander(f"‚úÖ {task['title']}", expanded=False):
                    st.write(f"**Completed:** {completed_date}")
                    if task['description']:
                        st.write(f"**Description:** {task['description']}")
                    if task['due_date']:
                        st.write(f"**Was due:** {task['due_date']}")
                    
                    if st.button("üóëÔ∏è Delete", key=f"delete_completed_{task['id']}", use_container_width=True):
                        db.delete_task(task['id'])
                        st.rerun()
        else:
            st.info("No completed tasks yet. Keep studying! üìö")
    
    # ==================== TAB 4: Statistics ====================
    with tab4:
        st.markdown("### üìä Task Statistics")
        
        all_tasks = db.get_user_tasks(user_id)
        
        if all_tasks:
            total_tasks = len(all_tasks)
            pending_tasks = len([t for t in all_tasks if t['status'] == 'pending'])
            in_progress_tasks = len([t for t in all_tasks if t['status'] == 'in_progress'])
            completed_tasks = len([t for t in all_tasks if t['status'] == 'completed'])
            
            # Overdue tasks
            today = datetime.now().date()
            overdue_tasks = 0
            for task in all_tasks:
                if task['status'] != 'completed' and task['due_date']:
                    due_date = datetime.strptime(task['due_date'], '%Y-%m-%d').date()
                    if due_date < today:
                        overdue_tasks += 1
            
            # Display metrics
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Total Tasks", total_tasks)
            
            with col2:
                st.metric("Pending", pending_tasks)
            
            with col3:
                st.metric("Completed", completed_tasks)
            
            with col4:
                st.metric("Overdue", overdue_tasks, delta=None if overdue_tasks == 0 else f"-{overdue_tasks}")
            
            st.markdown("---")
            
            # Completion rate
            if total_tasks > 0:
                completion_rate = (completed_tasks / total_tasks) * 100
                st.markdown(f"### üìà Completion Rate: {completion_rate:.1f}%")
                st.progress(completion_rate / 100)
            
            st.markdown("---")
            
            # Priority breakdown
            high_priority = len([t for t in all_tasks if t['priority'] == 'high' and t['status'] != 'completed'])
            medium_priority = len([t for t in all_tasks if t['priority'] == 'medium' and t['status'] != 'completed'])
            low_priority = len([t for t in all_tasks if t['priority'] == 'low' and t['status'] != 'completed'])
            
            st.markdown("### üéØ Active Tasks by Priority")
            
            col_a, col_b, col_c = st.columns(3)
            
            with col_a:
                st.metric("üî¥ High", high_priority)
            with col_b:
                st.metric("üü† Medium", medium_priority)
            with col_c:
                st.metric("üü¢ Low", low_priority)
        else:
            st.info("üìä No statistics yet. Create some tasks to see your progress!")
    
    # Back to dashboard
    st.markdown("---")
    if st.button("‚Üê Back to Dashboard", use_container_width=True):
        navigate_to('dashboard')
        

#This is pages/dashboard/quiz.py

import streamlit as st
from utils.auth import AuthManager
from database.db_manager import DatabaseManager
from utils.rag_system import RAGSystem
import json
import re
from datetime import datetime


def show_quiz_page(db: DatabaseManager, auth: AuthManager, navigate_to):
    """
    Display the quiz page for generating and taking quizzes
    
    Args:
        db: DatabaseManager instance
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    user_id = auth.get_current_user_id()
    
    # ==================== FULL-SCREEN QUIZ MODE ====================
    if st.session_state.get('taking_quiz', False) or st.session_state.get('show_results', False):
        # Hide sidebar during quiz
        st.markdown("""
            <style>
            [data-testid="stSidebar"] {display: none;}
            </style>
        """, unsafe_allow_html=True)
        
        # Get quiz info
        quiz_id = st.session_state.get('current_quiz_id')
        settings = db.get_user_settings(user_id)
        current_document_id = st.session_state.get('selected_document_id')
        current_document = db.get_document(current_document_id)
        
        if st.session_state.get('taking_quiz', False):
            # TAKING QUIZ MODE
            quiz_questions = db.get_quiz_questions(quiz_id)
            
            if quiz_questions:
                # Quiz header
                st.markdown(f"""
                    <div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                                padding: 2rem; border-radius: 15px; text-align: center; margin-bottom: 2rem;
                                box-shadow: 0 4px 15px rgba(0,0,0,0.2);'>
                        <h1 style='color: white; margin: 0;'>üìù Quiz Mode</h1>
                        <p style='color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0; font-size: 1.2rem;'>
                            {len(quiz_questions)} Questions
                        </p>
                    </div>
                """, unsafe_allow_html=True)
                
                # Initialize quiz state
                if 'quiz_answers' not in st.session_state:
                    st.session_state.quiz_answers = {}
                if 'quiz_start_time' not in st.session_state:
                    st.session_state.quiz_start_time = datetime.now()
                
                # Progress bar
                answered = len(st.session_state.quiz_answers)
                progress = answered / len(quiz_questions)
                st.progress(progress)
                st.markdown(f"**Progress:** {answered} / {len(quiz_questions)} questions answered")
                st.markdown("---")
                
                # Display questions
                for i, question in enumerate(quiz_questions, 1):
                    st.markdown(f"""
                        <div style='background-color: white; padding: 1.5rem; border-radius: 10px; 
                                    margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                                    border-left: 5px solid {"#4caf50" if question["id"] in st.session_state.quiz_answers else "#ccc"};'>
                            <h3 style='color: #333; margin: 0 0 1rem 0;'>
                                Question {i} of {len(quiz_questions)}
                            </h3>
                            <p style='font-size: 1.1rem; color: #555; margin-bottom: 1rem; line-height: 1.6;'>
                                {question['question']}
                            </p>
                        </div>
                    """, unsafe_allow_html=True)
                    
                    options = {
                        'A': question['option_a'],
                        'B': question['option_b'],
                        'C': question['option_c'],
                        'D': question['option_d']
                    }
                    
                    # Filter out empty options
                    options = {k: v for k, v in options.items() if v}
                    
                    answer = st.radio(
                        f"Select your answer:",
                        options=list(options.keys()),
                        format_func=lambda x: f"{x}. {options[x]}",
                        key=f"q_{question['id']}",
                        index=None,
                        label_visibility="collapsed"
                    )
                    
                    if answer:
                        st.session_state.quiz_answers[question['id']] = answer
                
                st.markdown("---")
                
                # Submit buttons
                col1, col2, col3 = st.columns([1, 2, 1])
                
                with col1:
                    if st.button("‚ùå Cancel Quiz", use_container_width=True):
                        st.session_state.taking_quiz = False
                        st.session_state.quiz_answers = {}
                        st.session_state.quiz_start_time = None
                        st.session_state.current_quiz_id = None
                        st.rerun()
                
                with col2:
                    if st.button("‚úÖ Submit Quiz", type="primary", use_container_width=True):
                        if len(st.session_state.quiz_answers) < len(quiz_questions):
                            st.error(f"‚ö†Ô∏è Please answer all {len(quiz_questions)} questions before submitting")
                        else:
                            # Calculate score
                            correct = 0
                            total = len(quiz_questions)
                            
                            # Create attempt
                            attempt_id = db.create_quiz_attempt(quiz_id, user_id)
                            
                            # Calculate time taken
                            time_taken = int((datetime.now() - st.session_state.quiz_start_time).total_seconds())
                            
                            # Store answers and calculate score
                            for question in quiz_questions:
                                user_answer = st.session_state.quiz_answers.get(question['id'])
                                is_correct = user_answer == question['correct_answer']
                                
                                if is_correct:
                                    correct += 1
                                
                                db.add_quiz_answer(
                                    attempt_id=attempt_id,
                                    question_id=question['id'],
                                    user_answer=user_answer,
                                    is_correct=is_correct
                                )
                            
                            score = (correct / total) * 100
                            
                            # Update attempt with score
                            db.complete_quiz_attempt(attempt_id, score, time_taken)
                            
                            # Store results for display
                            st.session_state.quiz_results = {
                                'score': score,
                                'correct': correct,
                                'total': total,
                                'time_taken': time_taken
                            }
                            st.session_state.show_results = True
                            st.session_state.taking_quiz = False
                            st.rerun()
        
        elif st.session_state.get('show_results', False):
            # RESULTS MODE
            results = st.session_state.quiz_results
            
            # Score display
            score = results['score']
            if score >= 90:
                emoji = "üèÜ"
                message = "Excellent!"
                color = "#4caf50"
            elif score >= 70:
                emoji = "üéâ"
                message = "Great job!"
                color = "#8bc34a"
            elif score >= 50:
                emoji = "üëç"
                message = "Good effort!"
                color = "#ff9800"
            else:
                emoji = "üìö"
                message = "Keep studying!"
                color = "#f44336"
            
            st.markdown(f"""
                <div style='background: linear-gradient(135deg, {color} 0%, {color}dd 100%); 
                            color: white; padding: 3rem; border-radius: 20px; text-align: center; 
                            margin: 2rem 0; box-shadow: 0 10px 30px rgba(0,0,0,0.2);'>
                    <h1 style='margin: 0; font-size: 5rem;'>{emoji}</h1>
                    <h2 style='margin: 1rem 0; font-size: 2rem;'>{message}</h2>
                    <h1 style='margin: 0.5rem 0; font-size: 4rem; font-weight: bold;'>{score:.1f}%</h1>
                    <p style='margin: 0; font-size: 1.5rem; opacity: 0.9;'>
                        {results['correct']} out of {results['total']} correct
                    </p>
                </div>
            """, unsafe_allow_html=True)
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("‚è±Ô∏è Time Taken", f"{results['time_taken'] // 60}m {results['time_taken'] % 60}s")
            with col2:
                st.metric("‚ö° Avg Time/Question", f"{results['time_taken'] / results['total']:.1f}s")
            with col3:
                accuracy_emoji = "üéØ" if score >= 80 else "üìä"
                st.metric(f"{accuracy_emoji} Accuracy", f"{score:.0f}%")
            
            st.markdown("---")
            
            # Action buttons
            col_a, col_b = st.columns(2)
            with col_a:
                if st.button("üîÑ Take Another Quiz", type="primary", use_container_width=True):
                    st.session_state.show_results = False
                    st.session_state.quiz_results = None
                    st.rerun()
            with col_b:
                if st.button("üìö Back to Quizzes", use_container_width=True):
                    st.session_state.show_results = False
                    st.session_state.quiz_results = None
                    st.rerun()
        
        return  # Exit here to prevent showing normal page
    
    # ==================== NORMAL PAGE MODE ====================
    
    # Page header
    st.markdown("""
        <div style='padding: 1rem 0;'>
            <h1 style='color: #1f77b4;'>‚ùì Quizzes</h1>
            <p style='color: #666; font-size: 1.1rem;'>Test your knowledge with AI-generated quizzes</p>
        </div>
    """, unsafe_allow_html=True)
    
    # Check Azure settings
    if not auth.has_azure_settings():
        st.warning("‚ö†Ô∏è **Azure OpenAI settings not configured**")
        if st.button("‚öôÔ∏è Go to Settings", type="primary"):
            navigate_to('settings')
        return
    
    # Get user settings
    settings = db.get_user_settings(user_id)
    
    # Get subjects
    subjects = db.get_user_subjects(user_id)
    
    if not subjects:
        st.warning("üìö **No subjects found**")
        if st.button("‚ûï Create Subject", type="primary"):
            navigate_to('subjects')
        return
    
    # Subject selector
    st.markdown("### üìö Select Subject")
    
    selected_subject_id = st.session_state.get('selected_subject_id')
    subject_options = {f"{s['name']}": s['id'] for s in subjects}
    
    if selected_subject_id:
        selected_subject = db.get_subject(selected_subject_id)
        if selected_subject:
            default_index = list(subject_options.keys()).index(selected_subject['name'])
        else:
            default_index = 0
    else:
        default_index = 0
    
    selected_subject_name = st.selectbox(
        "Choose a subject",
        options=list(subject_options.keys()),
        index=default_index,
        key="quiz_subject_selector"
    )
    
    current_subject_id = subject_options[selected_subject_name]
    st.session_state.selected_subject_id = current_subject_id
    
    # Get documents for subject
    documents = db.get_subject_documents(current_subject_id)
    completed_docs = [d for d in documents if d['processing_status'] == 'completed']
    
    if not completed_docs:
        st.warning(f"üìÑ **No processed documents in this subject**")
        if st.button("üì§ Upload Document", type="primary"):
            navigate_to('documents')
        return
    
    # Document selector
    st.markdown("### üìÑ Select Document")
    
    selected_document_id = st.session_state.get('selected_document_id')
    doc_options = {f"{d['title']}": d['id'] for d in completed_docs}
    
    if selected_document_id and selected_document_id in doc_options.values():
        selected_doc = db.get_document(selected_document_id)
        if selected_doc:
            default_doc_index = list(doc_options.keys()).index(selected_doc['title'])
        else:
            default_doc_index = 0
    else:
        default_doc_index = 0
    
    selected_doc_name = st.selectbox(
        "Choose a document",
        options=list(doc_options.keys()),
        index=default_doc_index,
        key="quiz_document_selector"
    )
    
    current_document_id = doc_options[selected_doc_name]
    current_document = db.get_document(current_document_id)
    st.session_state.selected_document_id = current_document_id
    
    st.markdown("---")
    
    # Initialize tab index
    if 'quiz_active_tab' not in st.session_state:
        st.session_state.quiz_active_tab = 0
    
    # Tabs for different sections
    tab1, tab2, tab3 = st.tabs(["üìù Generate Quiz", "üìö Quiz History", "üìä Statistics"])
    
    # Force switch to tab 1 if taking quiz
    with tab1:
        # This will be displayed in tab1
        pass 
        st.markdown("### üìù Create New Quiz")
        
        with st.form("quiz_generation_form"):
                col1, col2 = st.columns(2)
                
                with col1:
                    num_questions = st.slider(
                        "Number of Questions",
                        min_value=3,
                        max_value=20,
                        value=5,
                        help="How many questions to generate"
                    )
                    
                    difficulty = st.select_slider(
                        "Difficulty Level",
                        options=["easy", "medium", "hard"],
                        value="medium"
                    )
                
                with col2:
                    quiz_title = st.text_input(
                        "Quiz Title (optional)",
                        placeholder="Leave blank for auto-generated title",
                        help="Custom name for this quiz"
                    )
                    
                    topic_focus = st.text_input(
                        "Topic Focus (optional)",
                        placeholder="e.g., Chapter 3, Linear Algebra",
                        help="Focus on a specific topic"
                    )
                
                generate = st.form_submit_button("üé≤ Generate Quiz", type="primary", use_container_width=True)
                
                if generate:
                    with st.spinner(f"Generating {num_questions} questions... This may take a moment."):
                        try:
                            # Initialize RAG system
                            rag = RAGSystem(
                                azure_api_key=settings['azure_api_key'],
                                azure_endpoint=settings['azure_endpoint'],
                                azure_deployment_name=settings['azure_deployment_name'],
                                azure_api_version=settings['azure_api_version']
                            )
                            
                            # Load FAISS index
                            rag.load_index(current_document['faiss_index_path'])
                            
                            # Generate quiz
                            quiz_json = rag.generate_quiz_questions(
                                num_questions=num_questions,
                                difficulty=difficulty,
                                topic=topic_focus if topic_focus else None
                            )
                            
                            # Parse JSON response
                            try:
                                # Try to extract JSON from response
                                json_match = re.search(r'\[.*\]', quiz_json, re.DOTALL)
                                if json_match:
                                    questions_data = json.loads(json_match.group())
                                else:
                                    questions_data = json.loads(quiz_json)
                            except json.JSONDecodeError:
                                st.error("Failed to parse quiz questions. Please try again.")
                                questions_data = None
                            
                            if questions_data:
                                # Create quiz in database
                                title = quiz_title if quiz_title else f"Quiz - {current_document['title']} ({datetime.now().strftime('%Y-%m-%d %H:%M')})"
                                quiz_id = db.create_quiz(current_document_id, user_id, title)
                                
                                # Add questions to database
                                for q in questions_data:
                                    db.add_quiz_question(
                                        quiz_id=quiz_id,
                                        question=q.get('question', ''),
                                        correct_answer=q.get('correct_answer', ''),
                                        option_a=q.get('option_a', ''),
                                        option_b=q.get('option_b', ''),
                                        option_c=q.get('option_c', ''),
                                        option_d=q.get('option_d', ''),
                                        explanation=q.get('explanation', '')
                                    )
                                
                                st.success(f"‚úÖ Quiz '{title}' created with {len(questions_data)} questions!")
                                st.session_state.current_quiz_id = quiz_id
                                st.session_state.taking_quiz = True
                                st.rerun()
                                
                        except Exception as e:
                            st.error(f"‚ùå Error generating quiz: {str(e)}")
        
        # Take quiz section
        if  st.session_state.get('taking_quiz', False) and not st.session_state.get('show_results', False):
            st.markdown("---")
            quiz_id = st.session_state.get('current_quiz_id')
            
            if quiz_id:
                quiz_questions = db.get_quiz_questions(quiz_id)
                
                if quiz_questions:
                    # Get quiz info
                    quiz_info = db.get_quiz_questions(quiz_id)
                    quiz_data = next((q for q in db.get_document_quizzes(current_document_id) if q['id'] == quiz_id), None)
                    
                    if quiz_data:
                        st.markdown(f"""
                            <div style='background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); 
                                        padding: 2rem; border-radius: 15px; text-align: center; margin-bottom: 2rem;
                                        box-shadow: 0 4px 15px rgba(0,0,0,0.2);'>
                                <h2 style='color: white; margin: 0;'>üìù {quiz_data['title']}</h2>
                                <p style='color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0;'>
                                    {len(quiz_questions)} Questions
                                </p>
                            </div>
                        """, unsafe_allow_html=True)
                    
                    # Initialize quiz state
                    if 'quiz_answers' not in st.session_state:
                        st.session_state.quiz_answers = {}
                    if 'quiz_start_time' not in st.session_state:
                        st.session_state.quiz_start_time = datetime.now()
                    
                    # Display questions with better styling
                    for i, question in enumerate(quiz_questions, 1):
                        st.markdown(f"""
                            <div style='background-color: white; padding: 1.5rem; border-radius: 10px; 
                                        margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);'>
                                <h4 style='color: #333; margin: 0 0 1rem 0;'>
                                    Question {i} of {len(quiz_questions)}
                                </h4>
                                <p style='font-size: 1.1rem; color: #555; margin-bottom: 1rem;'>
                                    {question['question']}
                                </p>
                            </div>
                        """, unsafe_allow_html=True)
                        
                        options = {
                            'A': question['option_a'],
                            'B': question['option_b'],
                            'C': question['option_c'],
                            'D': question['option_d']
                        }
                        
                        # Filter out empty options
                        options = {k: v for k, v in options.items() if v}
                        
                        answer = st.radio(
                            f"Select your answer for Question {i}:",
                            options=list(options.keys()),
                            format_func=lambda x: f"{x}. {options[x]}",
                            key=f"history_q_{question['id']}",  # Changed to make unique
                            index=None,
                            label_visibility="collapsed"
                        )
                        
                        if answer:
                            st.session_state.quiz_answers[question['id']] = answer
                    
                    # Submit quiz
                    col_submit, col_cancel = st.columns(2)
                    
                    with col_submit:
                        if st.button("‚úÖ Submit Quiz", type="primary", use_container_width=True):
                            if len(st.session_state.quiz_answers) < len(quiz_questions):
                                st.warning(f"‚ö†Ô∏è Please answer all {len(quiz_questions)} questions before submitting")
                            else:
                                # Calculate score
                                correct = 0
                                total = len(quiz_questions)
                                
                                # Create attempt
                                attempt_id = db.create_quiz_attempt(quiz_id, user_id)
                                
                                # Calculate time taken
                                time_taken = int((datetime.now() - st.session_state.quiz_start_time).total_seconds())
                                
                                # Store answers and calculate score
                                for question in quiz_questions:
                                    user_answer = st.session_state.quiz_answers.get(question['id'])
                                    is_correct = user_answer == question['correct_answer']
                                    
                                    if is_correct:
                                        correct += 1
                                    
                                    db.add_quiz_answer(
                                        attempt_id=attempt_id,
                                        question_id=question['id'],
                                        user_answer=user_answer,
                                        is_correct=is_correct
                                    )
                                
                                score = (correct / total) * 100
                                
                                # Update attempt with score
                                db.complete_quiz_attempt(attempt_id, score, time_taken)
                                
                                # Store results for display
                                st.session_state.quiz_results = {
                                    'score': score,
                                    'correct': correct,
                                    'total': total,
                                    'time_taken': time_taken
                                }
                                st.session_state.show_results = True
                                st.session_state.taking_quiz = False
                                st.rerun()
                    
                    with col_cancel:
                        if st.button("Cancel Quiz", use_container_width=True):
                            st.session_state.taking_quiz = False
                            st.session_state.quiz_answers = {}
                            st.session_state.quiz_start_time = None
                            st.session_state.current_quiz_id = None
                            st.rerun()
        
        # Show results
        if st.session_state.get('show_results', False):
            st.markdown("---")
            results = st.session_state.quiz_results
            
            st.markdown("### üéØ Quiz Results")
            
            # Score display
            score = results['score']
            if score >= 90:
                emoji = "üèÜ"
                message = "Excellent!"
                color = "#4caf50"
            elif score >= 70:
                emoji = "üéâ"
                message = "Great job!"
                color = "#8bc34a"
            elif score >= 50:
                emoji = "üëç"
                message = "Good effort!"
                color = "#ff9800"
            else:
                emoji = "üìö"
                message = "Keep studying!"
                color = "#f44336"
            
            st.markdown(f"""
                <div style='background-color: {color}; color: white; padding: 2rem; 
                            border-radius: 10px; text-align: center; margin: 1rem 0;'>
                    <h1 style='margin: 0; font-size: 4rem;'>{emoji}</h1>
                    <h2 style='margin: 0.5rem 0;'>{message}</h2>
                    <h1 style='margin: 0.5rem 0; font-size: 3rem;'>{score:.1f}%</h1>
                    <p style='margin: 0; font-size: 1.2rem;'>
                        {results['correct']} out of {results['total']} correct
                    </p>
                </div>
            """, unsafe_allow_html=True)
            
            col1, col2 = st.columns(2)
            with col1:
                st.metric("Time Taken", f"{results['time_taken'] // 60}m {results['time_taken'] % 60}s")
            with col2:
                st.metric("Average Time per Question", f"{results['time_taken'] / results['total']:.1f}s")
            
            if st.button("üîÑ Take Another Quiz", type="primary", use_container_width=True):
                st.session_state.show_results = False
                st.session_state.quiz_results = None
                st.rerun()
    
    # ==================== TAB 2: Quiz History ====================
    with tab2:
        # Check if taking a quiz
        if st.session_state.get('taking_quiz', False) and not st.session_state.get('show_results', False):
            # SHOW QUIZ IN THIS TAB
            quiz_id = st.session_state.get('current_quiz_id')
            
            if quiz_id:
                quiz_questions = db.get_quiz_questions(quiz_id)
                
                if quiz_questions:
                    # Get quiz info
                    quiz_data = next((q for q in db.get_document_quizzes(current_document_id) if q['id'] == quiz_id), None)
                    
                    if quiz_data:
                        st.markdown(f"""
                            <div style='background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); 
                                        padding: 2rem; border-radius: 15px; text-align: center; margin-bottom: 2rem;
                                        box-shadow: 0 4px 15px rgba(0,0,0,0.2);'>
                                <h2 style='color: white; margin: 0;'>üìù {quiz_data['title']}</h2>
                                <p style='color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0;'>
                                    {len(quiz_questions)} Questions
                                </p>
                            </div>
                        """, unsafe_allow_html=True)
                    
                    # Initialize quiz state
                    if 'quiz_answers' not in st.session_state:
                        st.session_state.quiz_answers = {}
                    if 'quiz_start_time' not in st.session_state:
                        st.session_state.quiz_start_time = datetime.now()
                    
                    # Display questions with better styling
                    for i, question in enumerate(quiz_questions, 1):
                        st.markdown(f"""
                            <div style='background-color: white; padding: 1.5rem; border-radius: 10px; 
                                        margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);'>
                                <h4 style='color: #333; margin: 0 0 1rem 0;'>
                                    Question {i} of {len(quiz_questions)}
                                </h4>
                                <p style='font-size: 1.1rem; color: #555; margin-bottom: 1rem;'>
                                    {question['question']}
                                </p>
                            </div>
                        """, unsafe_allow_html=True)
                        
                        options = {
                            'A': question['option_a'],
                            'B': question['option_b'],
                            'C': question['option_c'],
                            'D': question['option_d']
                        }
                        
                        # Filter out empty options
                        options = {k: v for k, v in options.items() if v}
                        
                        answer = st.radio(
                            f"Select your answer for Question {i}:",
                            options=list(options.keys()),
                            format_func=lambda x: f"{x}. {options[x]}",
                            key=f"q_{question['id']}",
                            index=None,
                            label_visibility="collapsed"
                        )
                        
                        if answer:
                            st.session_state.quiz_answers[question['id']] = answer
                    
                    st.markdown("---")
                    
                    # Submit quiz
                    col_submit, col_cancel = st.columns(2)
                    
                    with col_submit:
                        if st.button("‚úÖ Submit Quiz", type="primary", use_container_width=True):
                            if len(st.session_state.quiz_answers) < len(quiz_questions):
                                st.warning(f"‚ö†Ô∏è Please answer all {len(quiz_questions)} questions before submitting")
                            else:
                                # Calculate score
                                correct = 0
                                total = len(quiz_questions)
                                
                                # Create attempt
                                attempt_id = db.create_quiz_attempt(quiz_id, user_id)
                                
                                # Calculate time taken
                                time_taken = int((datetime.now() - st.session_state.quiz_start_time).total_seconds())
                                
                                # Store answers and calculate score
                                for question in quiz_questions:
                                    user_answer = st.session_state.quiz_answers.get(question['id'])
                                    is_correct = user_answer == question['correct_answer']
                                    
                                    if is_correct:
                                        correct += 1
                                    
                                    db.add_quiz_answer(
                                        attempt_id=attempt_id,
                                        question_id=question['id'],
                                        user_answer=user_answer,
                                        is_correct=is_correct
                                    )
                                
                                score = (correct / total) * 100
                                
                                # Update attempt with score
                                db.complete_quiz_attempt(attempt_id, score, time_taken)
                                
                                # Store results for display
                                st.session_state.quiz_results = {
                                    'score': score,
                                    'correct': correct,
                                    'total': total,
                                    'time_taken': time_taken
                                }
                                st.session_state.show_results = True
                                st.session_state.taking_quiz = False
                                st.rerun()
                    
                    with col_cancel:
                        if st.button("Cancel Quiz", use_container_width=True):
                            st.session_state.taking_quiz = False
                            st.session_state.quiz_answers = {}
                            st.session_state.quiz_start_time = None
                            st.session_state.current_quiz_id = None
                            st.rerun()
        
        # Show results if just completed
        elif st.session_state.get('show_results', False):
            results = st.session_state.quiz_results
            
            st.markdown("### üéØ Quiz Results")
            
            # Score display
            score = results['score']
            if score >= 90:
                emoji = "üèÜ"
                message = "Excellent!"
                color = "#4caf50"
            elif score >= 70:
                emoji = "üéâ"
                message = "Great job!"
                color = "#8bc34a"
            elif score >= 50:
                emoji = "üëç"
                message = "Good effort!"
                color = "#ff9800"
            else:
                emoji = "üìö"
                message = "Keep studying!"
                color = "#f44336"
            
            st.markdown(f"""
                <div style='background-color: {color}; color: white; padding: 2rem; 
                            border-radius: 10px; text-align: center; margin: 1rem 0;'>
                    <h1 style='margin: 0; font-size: 4rem;'>{emoji}</h1>
                    <h2 style='margin: 0.5rem 0;'>{message}</h2>
                    <h1 style='margin: 0.5rem 0; font-size: 3rem;'>{score:.1f}%</h1>
                    <p style='margin: 0; font-size: 1.2rem;'>
                        {results['correct']} out of {results['total']} correct
                    </p>
                </div>
            """, unsafe_allow_html=True)
            
            col1, col2 = st.columns(2)
            with col1:
                st.metric("Time Taken", f"{results['time_taken'] // 60}m {results['time_taken'] % 60}s")
            with col2:
                st.metric("Average Time per Question", f"{results['time_taken'] / results['total']:.1f}s")
            
            col_a, col_b = st.columns(2)
            with col_a:
                if st.button("üîÑ Take Another Quiz", type="primary", use_container_width=True):
                    st.session_state.show_results = False
                    st.session_state.quiz_results = None
                    st.rerun()
            with col_b:
                if st.button("üìö Back to Quiz List", use_container_width=True):
                    st.session_state.show_results = False
                    st.session_state.quiz_results = None
                    st.rerun()
        
        # Show quiz list (default view)
        else:
            st.markdown("### üìö Your Quizzes")
            
            quizzes = db.get_document_quizzes(current_document_id)
            
            if quizzes:
                for quiz in quizzes:
                    attempts = db.get_quiz_attempts(quiz['id'])
                    num_attempts = len(attempts)
                    
                    # Calculate average score
                    if attempts:
                        avg_score = sum(a['score'] for a in attempts) / len(attempts)
                        best_score = max(a['score'] for a in attempts)
                    else:
                        avg_score = 0
                        best_score = 0
                    
                    # Quiz card with better styling
                    st.markdown(f"""
                        <div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                                    padding: 1.5rem; border-radius: 15px; margin-bottom: 1.5rem;
                                    box-shadow: 0 4px 15px rgba(0,0,0,0.1);'>
                            <h3 style='color: white; margin: 0 0 1rem 0;'>üìù {quiz['title']}</h3>
                            <div style='background-color: rgba(255,255,255,0.2); padding: 1rem; 
                                        border-radius: 10px; margin-bottom: 1rem;'>
                                <div style='display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;'>
                                    <div>
                                        <p style='color: rgba(255,255,255,0.8); font-size: 0.85rem; margin: 0;'>Created</p>
                                        <p style='color: white; font-weight: bold; margin: 0.3rem 0 0 0;'>{quiz['created_at'][:10]}</p>
                                    </div>
                                    <div>
                                        <p style='color: rgba(255,255,255,0.8); font-size: 0.85rem; margin: 0;'>Attempts</p>
                                        <p style='color: white; font-weight: bold; margin: 0.3rem 0 0 0;'>{num_attempts}</p>
                                    </div>
                                    <div>
                                        <p style='color: rgba(255,255,255,0.8); font-size: 0.85rem; margin: 0;'>Best Score</p>
                                        <p style='color: white; font-weight: bold; margin: 0.3rem 0 0 0;'>{best_score:.1f}%</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    """, unsafe_allow_html=True)
                    
                    # Get questions for this quiz
                    questions = db.get_quiz_questions(quiz['id'])
                    
                    # Action buttons
                    col_a, col_b, col_c = st.columns(3)
                    
                    with col_a:
                        if st.button("‚ñ∂Ô∏è Take Quiz", key=f"take_{quiz['id']}", use_container_width=True, type="primary"):
                            st.session_state.current_quiz_id = quiz['id']
                            st.session_state.taking_quiz = True
                            st.session_state.quiz_answers = {}
                            st.session_state.quiz_start_time = datetime.now()
                            st.session_state.show_results = False  # Reset results
                            st.rerun()
                    
                    with col_b:
                        with st.expander("üìä View Details"):
                            st.write(f"**Questions:** {len(questions)}")
                            st.write(f"**Average Score:** {avg_score:.1f}%")
                            
                            if attempts:
                                st.markdown("#### Recent Attempts")
                                for i, attempt in enumerate(attempts[-5:], 1):  # Last 5 attempts
                                    score_color = "#4caf50" if attempt['score'] >= 70 else "#ff9800" if attempt['score'] >= 50 else "#f44336"
                                    st.markdown(f"""
                                        <div style='background-color: rgba(255,255,255,0.2); padding: 0.5rem; border-radius: 5px; 
                                                    margin: 0.3rem 0; border-left: 3px solid {score_color};'>
                                            {attempt['attempt_date'][:10]} - Score: {attempt['score']:.1f}% - Time: {attempt['time_taken']}s
                                        </div>
                                    """, unsafe_allow_html=True)
                    
                    with col_c:
                        if st.button("üóëÔ∏è Delete Quiz", key=f"delete_quiz_{quiz['id']}", use_container_width=True):
                            st.session_state.deleting_quiz_id = quiz['id']
                            st.rerun()
            
           
                    # Delete confirmation
                    if st.session_state.get('deleting_quiz_id') == quiz['id']:
                        st.error("‚ö†Ô∏è **Delete this quiz?** All attempts and answers will also be deleted.")
                        col_yes, col_no = st.columns(2)

                        with col_yes:
                            if st.button(
                                "Yes, Delete",
                                key=f"confirm_delete_{quiz['id']}",   # unique key
                                type="primary",
                                use_container_width=True
                            ):
                                try:
                                    db.delete_quiz(quiz['id'])
                                    st.success("‚úÖ Quiz deleted successfully!")
                                except Exception as e:
                                    st.error(f"‚ùå Error deleting quiz: {str(e)}")
                                finally:
                                    st.session_state.deleting_quiz_id = None
                                    st.rerun()

                        with col_no:
                            if st.button(
                                "Cancel",
                                key=f"cancel_delete_{quiz['id']}",   # unique key
                                use_container_width=True
                            ):
                                st.session_state.deleting_quiz_id = None
                                st.rerun()
            else:
                st.info("üìù No quizzes yet. Generate your first quiz in the 'Generate Quiz' tab!")
    
    # ==================== TAB 3: Statistics ====================
    with tab3:
        st.markdown("### üìä Quiz Statistics")
        
        all_quizzes = db.get_document_quizzes(current_document_id)
        
        if all_quizzes:
            total_quizzes = len(all_quizzes)
            total_attempts = sum(len(db.get_quiz_attempts(q['id'])) for q in all_quizzes)
            
            all_attempts = []
            for quiz in all_quizzes:
                all_attempts.extend(db.get_quiz_attempts(quiz['id']))
            
            if all_attempts:
                avg_score = sum(a['score'] for a in all_attempts) / len(all_attempts)
                best_score = max(a['score'] for a in all_attempts)
                total_time = sum(a['time_taken'] for a in all_attempts)
            else:
                avg_score = 0
                best_score = 0
                total_time = 0
            
            # Display metrics
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Total Quizzes", total_quizzes)
            with col2:
                st.metric("Total Attempts", total_attempts)
            with col3:
                st.metric("Average Score", f"{avg_score:.1f}%")
            with col4:
                st.metric("Best Score", f"{best_score:.1f}%")
            
            st.markdown("---")
            
            col_a, col_b = st.columns(2)
            
            with col_a:
                st.metric("Total Study Time", f"{total_time // 60}m {total_time % 60}s")
            
            with col_b:
                if total_attempts > 0:
                    st.metric("Avg Time per Attempt", f"{total_time / total_attempts:.0f}s")
        else:
            st.info("üìä No statistics yet. Take some quizzes to see your progress!")
    
    # Back to dashboard
    st.markdown("---")
    if st.button("‚Üê Back to Dashboard", use_container_width=True):
        navigate_to('dashboard')

#This is pages/dashboard/settings.py
import streamlit as st
from utils.auth import AuthManager
from database.db_manager import DatabaseManager


def show_settings_page(db: DatabaseManager, auth: AuthManager, navigate_to):
    """
    Display the settings page for Azure OpenAI configuration
    
    Args:
        db: DatabaseManager instance
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    # Page header
    st.markdown("""
        <div style='padding: 1rem 0;'>
            <h1 style='color: #1f77b4;'>‚öôÔ∏è Settings</h1>
            <p style='color: #666; font-size: 1.1rem;'>Configure your Azure OpenAI credentials and preferences</p>
        </div>
    """, unsafe_allow_html=True)
    
    user_id = auth.get_current_user_id()
    
    # Tabs for different settings sections
    tab1, tab2, tab3 = st.tabs(["üîë Azure OpenAI", "üë§ Account", "‚ÑπÔ∏è Help"])
    
    # ==================== TAB 1: Azure OpenAI Settings ====================
    with tab1:
        st.markdown("### Azure OpenAI Configuration")
        
        # Get existing settings
        settings = db.get_user_settings(user_id)
        
        # Info box
        st.info("""
        **üìù Where to get these credentials:**
        
        1. Go to [Azure Portal](https://portal.azure.com)
        2. Navigate to your Azure OpenAI resource
        3. Go to "Keys and Endpoint" section
        4. Copy your API Key and Endpoint URL
        5. Note your deployment name from the "Deployments" section
        """)
        
        # Configuration form
        with st.form("azure_settings_form"):
            st.markdown("#### Required Configuration")
            
            azure_api_key = st.text_input(
                "Azure OpenAI API Key *",
                type="password",
                value=settings['azure_api_key'] if settings and settings.get('azure_api_key') else "",
                help="Your Azure OpenAI API key (will be encrypted)",
                placeholder="Enter your Azure OpenAI API key"
            )
            
            azure_endpoint = st.text_input(
                "Azure OpenAI Endpoint *",
                value=settings['azure_endpoint'] if settings and settings.get('azure_endpoint') else "",
                help="Your Azure OpenAI endpoint URL",
                placeholder="https://your-resource.openai.azure.com/"
            )
            
            azure_deployment_name = st.text_input(
                "Azure Deployment Name *",
                value=settings['azure_deployment_name'] if settings and settings.get('azure_deployment_name') else "",
                help="The name of your deployed model",
                placeholder="gpt-4"
            )
            
            azure_api_version = st.text_input(
                "Azure API Version *",
                value=settings['azure_api_version'] if settings and settings.get('azure_api_version') else "2024-02-15-preview",
                help="Azure OpenAI API version",
                placeholder="2024-02-15-preview"
            )
            
            st.markdown("#### Model Configuration")
            
            col1, col2 = st.columns(2)
            
            with col1:
                embedding_model = st.text_input(
                    "Embedding Model",
                    value=settings['embedding_model'] if settings and settings.get('embedding_model') else "text-embedding-ada-002",
                    help="Model used for creating embeddings"
                )
            
            with col2:
                chat_model = st.text_input(
                    "Chat Model",
                    value=settings['chat_model'] if settings and settings.get('chat_model') else "gpt-4",
                    help="Model used for chat completions"
                )
            
            st.markdown("---")
            
            # Submit buttons
            col_a, col_b = st.columns([3, 1])
            
            with col_a:
                submit = st.form_submit_button("üíæ Save Configuration", type="primary", use_container_width=True)
            
            with col_b:
                test = st.form_submit_button("üß™ Test", use_container_width=True)
            
            if submit:
                if not all([azure_api_key, azure_endpoint, azure_deployment_name, azure_api_version]):
                    st.error("‚ö†Ô∏è Please fill in all required fields (marked with *)")
                else:
                    try:
                        # Save settings
                        success = db.save_user_settings(
                            user_id=user_id,
                            azure_api_key=azure_api_key,
                            azure_endpoint=azure_endpoint,
                            azure_deployment_name=azure_deployment_name,
                            azure_api_version=azure_api_version,
                            embedding_model=embedding_model,
                            chat_model=chat_model
                        )
                        
                        if success:
                            st.success("‚úÖ Settings saved successfully!")
                            st.balloons()
                            
                            # Rerun to update the form with new values
                            import time
                            time.sleep(1)
                            st.rerun()
                        else:
                            st.error("‚ùå Failed to save settings. Please try again.")
                    except Exception as e:
                        st.error(f"‚ùå Error saving settings: {str(e)}")
            
            if test:
                if not all([azure_api_key, azure_endpoint, azure_deployment_name, azure_api_version]):
                    st.error("‚ö†Ô∏è Please fill in all required fields before testing")
                else:
                    with st.spinner("Testing Azure OpenAI connection..."):
                        try:
                            from openai import AzureOpenAI
                            
                            # Test connection
                            client = AzureOpenAI(
                                api_key=azure_api_key,
                                api_version=azure_api_version,
                                azure_endpoint=azure_endpoint
                            )
                            
                            # Try a simple completion
                            response = client.chat.completions.create(
                                model=azure_deployment_name,
                                messages=[{"role": "user", "content": "Hello"}],
                                max_tokens=10
                            )
                            
                            st.success("‚úÖ Connection successful! Your Azure OpenAI credentials are working.")
                            st.info(f"Response preview: {response.choices[0].message.content}")
                            
                        except Exception as e:
                            st.error(f"‚ùå Connection failed: {str(e)}")
                            st.warning("Please check your credentials and try again.")
        
        # Show current status
        st.markdown("---")
        st.markdown("### üìä Configuration Status")
        
        if settings and settings.get('azure_api_key'):
            st.success("‚úÖ Azure OpenAI credentials are configured")
            
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"**Endpoint:** {settings['azure_endpoint'][:50]}..." if len(settings['azure_endpoint']) > 50 else f"**Endpoint:** {settings['azure_endpoint']}")
                st.write(f"**Deployment:** {settings['azure_deployment_name']}")
            with col2:
                st.write(f"**API Version:** {settings['azure_api_version']}")
                st.write(f"**Embedding Model:** {settings['embedding_model']}")
        else:
            st.warning("‚ö†Ô∏è Azure OpenAI credentials not configured yet")
    
    # ==================== TAB 2: Account Settings ====================
    with tab2:
        st.markdown("### Account Information")
        
        user = auth.get_current_user()
        
        # Display account info
        col1, col2 = st.columns(2)
        
        with col1:
            st.text_input("Username", value=user['username'], disabled=True)
            st.text_input("Email", value=user['email'], disabled=True)
        
        with col2:
            st.text_input("Account Created", value=user['created_at'][:10], disabled=True)
            if user['last_login']:
                st.text_input("Last Login", value=user['last_login'][:10], disabled=True)
        
        st.markdown("---")
        
        # Change password section
        st.markdown("### üîí Change Password")
        
        with st.form("change_password_form"):
            current_password = st.text_input(
                "Current Password",
                type="password",
                placeholder="Enter your current password"
            )
            
            new_password = st.text_input(
                "New Password",
                type="password",
                placeholder="Enter your new password"
            )
            
            confirm_new_password = st.text_input(
                "Confirm New Password",
                type="password",
                placeholder="Re-enter your new password"
            )
            
            with st.expander("‚ÑπÔ∏è Password Requirements"):
                st.markdown("""
                Your password must contain:
                - At least **8 characters**
                - At least **one uppercase letter** (A-Z)
                - At least **one lowercase letter** (a-z)
                - At least **one digit** (0-9)
                """)
            
            if st.form_submit_button("Change Password", type="primary", use_container_width=True):
                if not all([current_password, new_password, confirm_new_password]):
                    st.error("‚ö†Ô∏è Please fill in all fields")
                else:
                    success, message = auth.change_password(
                        current_password, 
                        new_password, 
                        confirm_new_password
                    )
                    
                    if success:
                        st.success(f"‚úÖ {message}")
                    else:
                        st.error(f"‚ùå {message}")
        
        st.markdown("---")
        
        # Danger zone
        st.markdown("### ‚ö†Ô∏è Danger Zone")
        
        with st.expander("Delete Account", expanded=False):
            st.warning("""
            **Warning:** This action cannot be undone. This will permanently delete:
            - Your account and profile
            - All subjects and documents
            - All chat history, quizzes, and flashcards
            - All tasks and study plans
            """)
            
            st.text_input(
                "Type 'DELETE' to confirm",
                key="delete_confirmation",
                placeholder="Type DELETE to confirm"
            )
            
            if st.button("üóëÔ∏è Delete My Account", type="secondary"):
                if st.session_state.get("delete_confirmation") == "DELETE":
                    st.error("Account deletion feature is disabled in this demo")
                    # In production, you would implement:
                    # db.delete_user_and_all_data(user_id)
                    # auth.logout()
                    # navigate_to('home')
                else:
                    st.error("Please type 'DELETE' to confirm")
    
    # ==================== TAB 3: Help ====================
    with tab3:
        st.markdown("### üìñ Help & Documentation")
        
        st.markdown("#### Getting Started")
        st.markdown("""
        1. **Configure Azure OpenAI** in the first tab
        2. **Create subjects** for your courses
        3. **Upload documents** (PDF, DOCX, TXT)
        4. **Start using AI features** - chat, quizzes, flashcards
        """)
        
        st.markdown("---")
        
        st.markdown("#### Frequently Asked Questions")
        
        with st.expander("‚ùì How do I get Azure OpenAI credentials?"):
            st.markdown("""
            1. Create an Azure account at [portal.azure.com](https://portal.azure.com)
            2. Create an Azure OpenAI resource
            3. Deploy a model (e.g., GPT-4)
            4. Get your API key from "Keys and Endpoint"
            5. Copy the endpoint URL and deployment name
            """)
        
        with st.expander("‚ùì What document formats are supported?"):
            st.markdown("""
            Currently supported formats:
            - **PDF** (.pdf)
            - **Word Documents** (.docx)
            - **Text Files** (.txt)
            - **Markdown** (.md)
            """)
        
        with st.expander("‚ùì Is my data secure?"):
            st.markdown("""
            Yes! Your data is secure:
            - API keys are encrypted before storage
            - Documents are stored locally
            - You use your own Azure OpenAI instance
            - No data is shared with third parties
            """)
        
        with st.expander("‚ùì How does the RAG system work?"):
            st.markdown("""
            RAG (Retrieval-Augmented Generation) works by:
            1. Breaking your documents into chunks
            2. Creating embeddings (vector representations)
            3. Storing them in a FAISS index
            4. Finding relevant chunks when you ask questions
            5. Using those chunks as context for AI responses
            """)
        
        with st.expander("‚ùì Can I use multiple documents?"):
            st.markdown("""
            Yes! You can:
            - Create multiple subjects
            - Add unlimited documents to each subject
            - Chat with individual documents or entire subjects
            - Generate quizzes and flashcards from any document
            """)
        
        st.markdown("---")
        
        st.markdown("#### Support")
        st.info("""
        **Need help?**
        
        This is a diploma project demonstration. For questions or issues:
        - Review the documentation above
        - Check your Azure OpenAI configuration
        - Ensure your API keys are valid
        """)
        
        st.markdown("---")
        
        st.markdown("#### About This Project")
        st.markdown("""
        **AI Study Assistant** is a diploma project demonstrating:
        - Azure OpenAI integration
        - RAG (Retrieval-Augmented Generation)
        - FAISS vector search
        - Streamlit web application development
        - Secure credential management
        - Document processing and AI-powered learning tools
        """)
    
    # Back to dashboard button
    st.markdown("---")
    if st.button("‚Üê Back to Dashboard", use_container_width=True):
        navigate_to('dashboard')

#This is pages/dashboard/subjects.py

import streamlit as st
from utils.auth import AuthManager
from database.db_manager import DatabaseManager


def show_subjects_page(db: DatabaseManager, auth: AuthManager, navigate_to):
    """
    Display the subjects management page
    
    Args:
        db: DatabaseManager instance
        auth: AuthManager instance
        navigate_to: Navigation function
    """
    
    # Page header
    st.markdown("""
        <div style='padding: 1rem 0;'>
            <h1 style='color: #1f77b4;'>üìñ Subjects</h1>
            <p style='color: #666; font-size: 1.1rem;'>Organize your study materials by subject</p>
        </div>
    """, unsafe_allow_html=True)
    
    user_id = auth.get_current_user_id()
    
    # Get all subjects
    subjects = db.get_user_subjects(user_id)
    
    # Action buttons
    col1, col2, col3 = st.columns([2, 2, 6])
    
    with col1:
        if st.button("‚ûï Create Subject", type="primary", use_container_width=True):
            st.session_state.show_create_form = True
            st.session_state.show_edit_form = False
    
    with col2:
        if st.button("üîÑ Refresh", use_container_width=True):
            st.rerun()
    
    st.markdown("---")
    
    # Create subject form
    if st.session_state.get('show_create_form', False):
        st.markdown("### ‚ûï Create New Subject")
        
        with st.form("create_subject_form", clear_on_submit=True):
            subject_name = st.text_input(
                "Subject Name *",
                placeholder="e.g., Computer Science, Mathematics, History",
                max_chars=100
            )
            
            subject_description = st.text_area(
                "Description",
                placeholder="Brief description of this subject (optional)",
                max_chars=500,
                height=100
            )
            
            # Color picker for subject
            colors = {
                "Blue": "#1f77b4",
                "Green": "#2ca02c",
                "Red": "#d62728",
                "Purple": "#9467bd",
                "Orange": "#ff7f0e",
                "Pink": "#e377c2",
                "Brown": "#8c564b",
                "Gray": "#7f7f7f"
            }
            
            col_a, col_b = st.columns([3, 1])
            with col_a:
                selected_color_name = st.selectbox(
                    "Color (for organization)",
                    options=list(colors.keys()),
                    help="Choose a color to help identify this subject"
                )
            with col_b:
                st.markdown(f"""
                    <div style='width: 100%; height: 50px; background-color: {colors[selected_color_name]}; 
                                border-radius: 5px; margin-top: 1.8rem;'></div>
                """, unsafe_allow_html=True)
            
            subject_color = colors[selected_color_name]
            
            col_submit, col_cancel = st.columns(2)
            
            with col_submit:
                submit = st.form_submit_button("Create Subject", type="primary", use_container_width=True)
            
            with col_cancel:
                cancel = st.form_submit_button("Cancel", use_container_width=True)
            
            if submit:
                if not subject_name:
                    st.error("‚ö†Ô∏è Please enter a subject name")
                else:
                    try:
                        subject_id = db.create_subject(
                            user_id=user_id,
                            name=subject_name,
                            description=subject_description,
                            color=subject_color
                        )
                        
                        if subject_id:
                            st.success(f"‚úÖ Subject '{subject_name}' created successfully!")
                            st.session_state.show_create_form = False
                            import time
                            time.sleep(1)
                            st.rerun()
                        else:
                            st.error("‚ùå Failed to create subject")
                    except Exception as e:
                        st.error(f"‚ùå Error: {str(e)}")
            
            if cancel:
                st.session_state.show_create_form = False
                st.rerun()
        
        st.markdown("---")
    
    # Display subjects
    if subjects:
        st.markdown(f"### üìö Your Subjects ({len(subjects)})")
        
        # Search/filter
        search_term = st.text_input("üîç Search subjects", placeholder="Type to search...")
        
        # Filter subjects by search term
        if search_term:
            filtered_subjects = [s for s in subjects if search_term.lower() in s['name'].lower() 
                               or (s['description'] and search_term.lower() in s['description'].lower())]
        else:
            filtered_subjects = subjects
        
        if not filtered_subjects:
            st.info("No subjects found matching your search.")
        else:
            # Display subjects in a grid
            cols_per_row = 2
            for i in range(0, len(filtered_subjects), cols_per_row):
                cols = st.columns(cols_per_row)
                
                for j, col in enumerate(cols):
                    idx = i + j
                    if idx < len(filtered_subjects):
                        subject = filtered_subjects[idx]
                        
                        with col:
                            # Get document count
                            docs = db.get_subject_documents(subject['id'])
                            doc_count = len(docs)
                            
                            # Subject card
                            card_color = subject['color'] if subject.get('color') else '#1f77b4'
                            
                            st.markdown(f"""
                                <div style='background-color: #f8f9fa; padding: 1.5rem; border-radius: 10px; 
                                            border-left: 5px solid {card_color}; margin-bottom: 1rem; min-height: 200px;'>
                                    <h3 style='margin: 0 0 0.5rem 0; color: {card_color};'>
                                        üìñ {subject['name']}
                                    </h3>
                                    <p style='color: #666; font-size: 0.9rem; margin: 0.5rem 0;'>
                                        {subject['description'] if subject['description'] else '<em>No description</em>'}
                                    </p>
                                    <p style='color: #999; font-size: 0.85rem; margin-top: 1rem;'>
                                        üìÑ {doc_count} document{'s' if doc_count != 1 else ''}
                                    </p>
                                </div>
                            """, unsafe_allow_html=True)
                            
                            # Action buttons
                            col_1, col_2, col_3, col_4 = st.columns(4)
                            
                            with col_1:
                                if st.button("üìÑ", key=f"docs_{subject['id']}", 
                                           help="View documents", use_container_width=True):
                                    st.session_state.selected_subject_id = subject['id']
                                    navigate_to('documents')
                            
                            with col_2:
                                if st.button("üí¨", key=f"chat_{subject['id']}", 
                                           help="Chat", use_container_width=True):
                                    st.session_state.selected_subject_id = subject['id']
                                    navigate_to('chat')
                            
                            with col_3:
                                if st.button("‚úèÔ∏è", key=f"edit_{subject['id']}", 
                                           help="Edit subject", use_container_width=True):
                                    st.session_state.editing_subject_id = subject['id']
                                    st.session_state.show_edit_form = True
                                    st.session_state.show_create_form = False
                                    st.rerun()
                            
                            with col_4:
                                if st.button("üóëÔ∏è", key=f"delete_{subject['id']}", 
                                           help="Delete subject", use_container_width=True):
                                    st.session_state.deleting_subject_id = subject['id']
                                    st.rerun()
            
            # Edit subject form
            if st.session_state.get('show_edit_form', False):
                st.markdown("---")
                editing_id = st.session_state.get('editing_subject_id')
                subject_to_edit = db.get_subject(editing_id)
                
                if subject_to_edit:
                    st.markdown(f"### ‚úèÔ∏è Edit Subject: {subject_to_edit['name']}")
                    
                    with st.form("edit_subject_form"):
                        edit_name = st.text_input(
                            "Subject Name *",
                            value=subject_to_edit['name'],
                            max_chars=100
                        )
                        
                        edit_description = st.text_area(
                            "Description",
                            value=subject_to_edit['description'] if subject_to_edit['description'] else "",
                            max_chars=500,
                            height=100
                        )
                        
                        # Color picker
                        colors = {
                            "Blue": "#1f77b4",
                            "Green": "#2ca02c",
                            "Red": "#d62728",
                            "Purple": "#9467bd",
                            "Orange": "#ff7f0e",
                            "Pink": "#e377c2",
                            "Brown": "#8c564b",
                            "Gray": "#7f7f7f"
                        }
                        
                        # Find current color
                        current_color = subject_to_edit.get('color', '#1f77b4')
                        current_color_name = next((name for name, hex_val in colors.items() 
                                                  if hex_val == current_color), "Blue")
                        
                        col_a, col_b = st.columns([3, 1])
                        with col_a:
                            selected_color_name = st.selectbox(
                                "Color",
                                options=list(colors.keys()),
                                index=list(colors.keys()).index(current_color_name)
                            )
                        with col_b:
                            st.markdown(f"""
                                <div style='width: 100%; height: 50px; background-color: {colors[selected_color_name]}; 
                                            border-radius: 5px; margin-top: 1.8rem;'></div>
                            """, unsafe_allow_html=True)
                        
                        edit_color = colors[selected_color_name]
                        
                        col_save, col_cancel = st.columns(2)
                        
                        with col_save:
                            save = st.form_submit_button("Save Changes", type="primary", use_container_width=True)
                        
                        with col_cancel:
                            cancel = st.form_submit_button("Cancel", use_container_width=True)
                        
                        if save:
                            if not edit_name:
                                st.error("‚ö†Ô∏è Please enter a subject name")
                            else:
                                try:
                                    db.update_subject(
                                        subject_id=editing_id,
                                        name=edit_name,
                                        description=edit_description,
                                        color=edit_color
                                    )
                                    st.success(f"‚úÖ Subject '{edit_name}' updated successfully!")
                                    st.session_state.show_edit_form = False
                                    st.session_state.editing_subject_id = None
                                    import time
                                    time.sleep(1)
                                    st.rerun()
                                except Exception as e:
                                    st.error(f"‚ùå Error: {str(e)}")
                        
                        if cancel:
                            st.session_state.show_edit_form = False
                            st.session_state.editing_subject_id = None
                            st.rerun()
            
            # Delete confirmation dialog
            if st.session_state.get('deleting_subject_id'):
                st.markdown("---")
                deleting_id = st.session_state.deleting_subject_id
                subject_to_delete = db.get_subject(deleting_id)
                
                if subject_to_delete:
                    st.error(f"### ‚ö†Ô∏è Delete Subject: {subject_to_delete['name']}?")
                    
                    docs = db.get_subject_documents(deleting_id)
                    doc_count = len(docs)
                    
                    st.warning(f"""
                    **Warning:** This will permanently delete:
                    - The subject "{subject_to_delete['name']}"
                    - All {doc_count} document(s) in this subject
                    - All associated chat history, quizzes, and flashcards
                    
                    This action cannot be undone!
                    """)
                    
                    col_confirm, col_cancel = st.columns(2)
                    
                    with col_confirm:
                        if st.button("üóëÔ∏è Yes, Delete", type="primary", use_container_width=True):
                            try:
                                db.delete_subject(deleting_id)
                                st.success(f"‚úÖ Subject '{subject_to_delete['name']}' deleted successfully!")
                                st.session_state.deleting_subject_id = None
                                import time
                                time.sleep(1)
                                st.rerun()
                            except Exception as e:
                                st.error(f"‚ùå Error: {str(e)}")
                    
                    with col_cancel:
                        if st.button("Cancel", use_container_width=True):
                            st.session_state.deleting_subject_id = None
                            st.rerun()
    else:
        # Empty state
        st.info("üìö **No subjects yet**")
        st.markdown("""
        Get started by creating your first subject! Subjects help you organize your study materials by course or topic.
        
        **Examples:**
        - Computer Science
        - Mathematics
        - History
        - Biology
        - Literature
        """)
        
        if st.button("‚ûï Create Your First Subject", type="primary"):
            st.session_state.show_create_form = True
            st.rerun()
    
    # Back to dashboard
    st.markdown("---")
    if st.button("‚Üê Back to Dashboard", use_container_width=True):
        navigate_to('dashboard')

#This is utils/auth.py
import streamlit as st
import bcrypt
from typing import Optional, Dict
from database.db_manager import DatabaseManager
import re


class AuthManager:
    """Handles user authentication and session management"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db = db_manager
        self._initialize_session_state()
    
    def _initialize_session_state(self):
        """Initialize session state variables if they don't exist"""
        if 'user' not in st.session_state:
            st.session_state.user = None
        if 'user_id' not in st.session_state:
            st.session_state.user_id = None
        if 'username' not in st.session_state:
            st.session_state.username = None
        if 'email' not in st.session_state:
            st.session_state.email = None
    
    @staticmethod
    
    def hash_password(password: str) -> str:
        """Hash a password using bcrypt"""
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')
    
    @staticmethod
    def verify_password(password: str, hashed_password: str) -> bool:
        """Verify a password against its hash"""
        return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))
    
    @staticmethod
    def validate_email(email: str) -> bool:
        """Validate email format"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    @staticmethod
    def validate_password(password: str) -> tuple[bool, str]:
        """
        Validate password strength
        Returns: (is_valid, error_message)
        """
        if len(password) < 8:
            return False, "Password must be at least 8 characters long"
        if not re.search(r'[A-Z]', password):
            return False, "Password must contain at least one uppercase letter"
        if not re.search(r'[a-z]', password):
            return False, "Password must contain at least one lowercase letter"
        if not re.search(r'\d', password):
            return False, "Password must contain at least one digit"
        return True, ""
    
    @staticmethod
    def validate_username(username: str) -> tuple[bool, str]:
        """
        Validate username
        Returns: (is_valid, error_message)
        """
        if len(username) < 3:
            return False, "Username must be at least 3 characters long"
        if len(username) > 20:
            return False, "Username must be no more than 20 characters"
        if not re.match(r'^[a-zA-Z0-9_]+$', username):
            return False, "Username can only contain letters, numbers, and underscores"
        return True, ""
    
    def signup(self, email: str, username: str, password: str, confirm_password: str) -> tuple[bool, str]:
        """
        Register a new user
        Returns: (success, message)
        """
        # Validate email
        if not self.validate_email(email):
            return False, "Invalid email format"
        
        # Validate username
        is_valid, message = self.validate_username(username)
        if not is_valid:
            return False, message
        
        # Validate password
        is_valid, message = self.validate_password(password)
        if not is_valid:
            return False, message
        
        # Check if passwords match
        if password != confirm_password:
            return False, "Passwords do not match"
        
        # Check if email already exists
        if self.db.get_user_by_email(email):
            return False, "Email already registered"
        
        # Check if username already exists
        if self.db.get_user_by_username(username):
            return False, "Username already taken"
        
        # Hash password and create user
        password_hash = self.hash_password(password)
        user_id = self.db.create_user(email, username, password_hash)
        
        if user_id:
            return True, "Account created successfully! Please login."
        else:
            return False, "An error occurred during registration"
    
    def login(self, email_or_username: str, password: str) -> tuple[bool, str]:
        """
        Authenticate user and create session
        Returns: (success, message)
        """
        # Try to find user by email or username
        user = None
        if self.validate_email(email_or_username):
            user = self.db.get_user_by_email(email_or_username)
        else:
            user = self.db.get_user_by_username(email_or_username)
        
        if not user:
            return False, "Invalid credentials"
        
        # Verify password
        if not self.verify_password(password, user['password_hash']):
            return False, "Invalid credentials"
        
        # Update last login
        self.db.update_last_login(user['id'])
        
        # Set session state
        st.session_state.user = user
        st.session_state.user_id = user['id']
        st.session_state.username = user['username']
        st.session_state.email = user['email']
        
        return True, f"Welcome back, {user['username']}!"
    
    def logout(self):
        """Clear session and log out user"""
        st.session_state.user = None
        st.session_state.user_id = None
        st.session_state.username = None
        st.session_state.email = None
        
        # Clear any other session state variables
        for key in list(st.session_state.keys()):
            if key not in ['user', 'user_id', 'username', 'email']:
                del st.session_state[key]
    
    def is_authenticated(self) -> bool:
        """Check if user is authenticated"""
        return st.session_state.user is not None and st.session_state.user_id is not None
    
    def require_authentication(self):
        """Decorator/function to require authentication for a page"""
        if not self.is_authenticated():
            st.warning("Please login to access this page")
            st.stop()
    
    def get_current_user(self) -> Optional[Dict]:
        """Get currently logged in user"""
        return st.session_state.user
    
    def get_current_user_id(self) -> Optional[int]:
        """Get current user ID"""
        return st.session_state.user_id
    
    def get_current_username(self) -> Optional[str]:
        """Get current username"""
        return st.session_state.username
    
    def change_password(self, current_password: str, new_password: str, 
                       confirm_new_password: str) -> tuple[bool, str]:
        """
        Change user's password
        Returns: (success, message)
        """
        if not self.is_authenticated():
            return False, "User not authenticated"
        
        user = self.get_current_user()
        
        # Verify current password
        if not self.verify_password(current_password, user['password_hash']):
            return False, "Current password is incorrect"
        
        # Validate new password
        is_valid, message = self.validate_password(new_password)
        if not is_valid:
            return False, message
        
        # Check if passwords match
        if new_password != confirm_new_password:
            return False, "New passwords do not match"
        
        # Check if new password is different from current
        if current_password == new_password:
            return False, "New password must be different from current password"
        
        # Hash and update password
        new_password_hash = self.hash_password(new_password)
        
        # Update in database (you'll need to add this method to DatabaseManager)
        # For now, we'll assume it exists
        # self.db.update_user_password(user['id'], new_password_hash)
        
        return True, "Password changed successfully"
    
    def get_user_settings(self) -> Optional[Dict]:
        """Get settings for current user"""
        if not self.is_authenticated():
            return None
        return self.db.get_user_settings(st.session_state.user_id)
    
    def has_azure_settings(self) -> bool:
        """Check if user has configured Azure OpenAI settings"""
        settings = self.get_user_settings()
        if not settings:
            return False
        return all([
            settings.get('azure_api_key'),
            settings.get('azure_endpoint'),
            settings.get('azure_deployment_name')
        ])


# Utility function for quick authentication check
def require_auth(db_manager: DatabaseManager):
    """Quick function to require authentication on a page"""
    auth = AuthManager(db_manager)
    auth.require_authentication()
    return auth

#This is utils/document_processor.py
import os
from typing import List, Dict, Tuple, Optional
import re
from pathlib import Path

# PDF processing
try:
    import PyPDF2
except ImportError:
    PyPDF2 = None

try:
    from pdfminer.high_level import extract_text as pdfminer_extract_text
except ImportError:
    pdfminer_extract_text = None

# DOCX processing
try:
    from docx import Document as DocxDocument
except ImportError:
    DocxDocument = None

# TXT processing
try:
    import chardet
except ImportError:
    chardet = None


class DocumentProcessor:
    """Processes various document formats and prepares them for RAG"""
    
    def __init__(self, chunk_size: int = 1000, chunk_overlap: int = 200):
        """
        Initialize document processor
        
        Args:
            chunk_size: Target size for each text chunk (in characters)
            chunk_overlap: Number of characters to overlap between chunks
        """
        self.chunk_size = chunk_size
        self.chunk_overlap = chunk_overlap
        self.supported_formats = ['.pdf', '.docx', '.txt', '.md']
    
    def is_supported_format(self, file_path: str) -> bool:
        """Check if file format is supported"""
        ext = Path(file_path).suffix.lower()
        return ext in self.supported_formats
    
    def extract_text_from_pdf(self, file_path: str) -> Tuple[str, List[Dict]]:
        """
        Extract text from PDF file
        
        Args:
            file_path: Path to PDF file
            
        Returns:
            Tuple of (full_text, page_metadata)
        """
        if not PyPDF2:
            raise ImportError("PyPDF2 is not installed. Install it with: pip install PyPDF2")
        
        text_parts = []
        page_metadata = []
        
        try:
            # Try PyPDF2 first (faster but sometimes less accurate)
            with open(file_path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)
                num_pages = len(pdf_reader.pages)
                
                for page_num in range(num_pages):
                    page = pdf_reader.pages[page_num]
                    text = page.extract_text()
                    
                    if text.strip():
                        text_parts.append(text)
                        page_metadata.append({
                            'page': page_num + 1,
                            'total_pages': num_pages,
                            'char_start': len(''.join(text_parts[:-1])),
                            'char_end': len(''.join(text_parts))
                        })
        except Exception as e:
            if pdfminer_extract_text:
                print(f"PyPDF2 failed, trying pdfminer: {e}")
                # Fallback to pdfminer if PyPDF2 fails
                try:
                    text = pdfminer_extract_text(file_path)
                    text_parts = [text]
                    page_metadata = [{'page': 1, 'total_pages': 1, 'char_start': 0, 'char_end': len(text)}]
                except Exception as e2:
                    raise Exception(f"Failed to extract PDF text: {e2}")
            else:
                raise Exception(f"Failed to extract PDF text and pdfminer is not installed: {e}")
        
        full_text = '\n\n'.join(text_parts)
        return full_text, page_metadata
    
    def extract_text_from_docx(self, file_path: str) -> Tuple[str, List[Dict]]:
        """
        Extract text from DOCX file
        
        Args:
            file_path: Path to DOCX file
            
        Returns:
            Tuple of (full_text, paragraph_metadata)
        """
        if not DocxDocument:
            raise ImportError("python-docx is not installed. Install it with: pip install python-docx")
        
        try:
            doc = DocxDocument(file_path)
            text_parts = []
            para_metadata = []
            
            for i, paragraph in enumerate(doc.paragraphs):
                text = paragraph.text.strip()
                if text:
                    text_parts.append(text)
                    para_metadata.append({
                        'paragraph': i + 1,
                        'char_start': len('\n\n'.join(text_parts[:-1])),
                        'char_end': len('\n\n'.join(text_parts))
                    })
            
            full_text = '\n\n'.join(text_parts)
            return full_text, para_metadata
            
        except Exception as e:
            raise Exception(f"Failed to extract DOCX text: {e}")
    
    def extract_text_from_txt(self, file_path: str) -> Tuple[str, List[Dict]]:
        """
        Extract text from TXT file
        
        Args:
            file_path: Path to TXT file
            
        Returns:
            Tuple of (full_text, metadata)
        """
        try:
            # Detect encoding if chardet is available
            encoding = 'utf-8'
            if chardet:
                with open(file_path, 'rb') as file:
                    raw_data = file.read()
                    result = chardet.detect(raw_data)
                    encoding = result['encoding'] or 'utf-8'
            
            # Read with detected encoding
            with open(file_path, 'r', encoding=encoding, errors='ignore') as file:
                text = file.read()
            
            metadata = [{'format': 'txt', 'char_start': 0, 'char_end': len(text)}]
            return text, metadata
            
        except Exception as e:
            raise Exception(f"Failed to extract TXT text: {e}")
    
    def extract_text(self, file_path: str) -> Tuple[str, List[Dict]]:
        """
        Extract text from any supported document format
        
        Args:
            file_path: Path to document file
            
        Returns:
            Tuple of (full_text, metadata)
        """
        ext = Path(file_path).suffix.lower()
        
        if ext == '.pdf':
            return self.extract_text_from_pdf(file_path)
        elif ext == '.docx':
            return self.extract_text_from_docx(file_path)
        elif ext in ['.txt', '.md']:
            return self.extract_text_from_txt(file_path)
        else:
            raise ValueError(f"Unsupported file format: {ext}")
    
    def clean_text(self, text: str) -> str:
        """
        Clean and normalize extracted text
        
        Args:
            text: Raw text to clean
            
        Returns:
            Cleaned text
        """
        # Remove excessive whitespace
        text = re.sub(r'\s+', ' ', text)
        
        # Remove excessive newlines (keep paragraph breaks)
        text = re.sub(r'\n{3,}', '\n\n', text)
        
        # Remove special characters that might cause issues
        text = text.replace('\x00', '')
        
        # Strip leading/trailing whitespace
        text = text.strip()
        
        return text
    
    def split_into_sentences(self, text: str) -> List[str]:
        """
        Split text into sentences
        
        Args:
            text: Text to split
            
        Returns:
            List of sentences
        """
        # Simple sentence splitting 
        sentences = re.split(r'(?<=[.!?])\s+', text)
        return [s.strip() for s in sentences if s.strip()]
    
    def create_chunks(self, text: str, metadata: Optional[List[Dict]] = None) -> List[Dict]:
        """
        Split text into overlapping chunks
        
        Args:
            text: Text to chunk
            metadata: Optional source metadata
            
        Returns:
            List of chunk dictionaries with text and metadata
        """
        # Clean text first
        text = self.clean_text(text)
        
        chunks = []
        start = 0
        text_length = len(text)
        chunk_id = 0
        
        while start < text_length:
            # Calculate end position
            end = start + self.chunk_size
            
            # If we're not at the end, try to break at a sentence boundary
            if end < text_length:
                # Look for sentence ending punctuation
                last_period = text.rfind('.', start, end)
                last_exclamation = text.rfind('!', start, end)
                last_question = text.rfind('?', start, end)
                
                # Find the last sentence boundary
                break_point = max(last_period, last_exclamation, last_question)
                
                # If we found a good break point, use it
                if break_point > start + (self.chunk_size // 2):  # Ensure chunk isn't too small
                    end = break_point + 1
            
            # Extract chunk
            chunk_text = text[start:end].strip()
            
            if chunk_text:
                chunk_data = {
                    'text': chunk_text,
                    'chunk_id': chunk_id,
                    'char_start': start,
                    'char_end': end,
                    'chunk_size': len(chunk_text)
                }
                
                # Add source metadata if provided
                if metadata:
                    # Find which metadata entry this chunk belongs to
                    for meta in metadata:
                        if 'char_start' in meta and 'char_end' in meta:
                            if start >= meta['char_start'] and start < meta['char_end']:
                                chunk_data.update({k: v for k, v in meta.items() 
                                                 if k not in ['char_start', 'char_end']})
                                break
                
                chunks.append(chunk_data)
                chunk_id += 1
            
            # Move start position (with overlap)
            start = end - self.chunk_overlap
            
            # Prevent infinite loop
            if start <= 0 or end >= text_length:
                break
        
        return chunks
    
    def process_document(self, file_path: str) -> Tuple[List[str], List[Dict], Dict]:
        """
        Complete document processing pipeline
        
        Args:
            file_path: Path to document
            
        Returns:
            Tuple of (chunk_texts, chunk_metadata, document_stats)
        """
        # Extract text
        full_text, source_metadata = self.extract_text(file_path)
        
        # Create chunks
        chunks = self.create_chunks(full_text, source_metadata)
        
        # Separate text and metadata
        chunk_texts = [chunk['text'] for chunk in chunks]
        chunk_metadata = [{k: v for k, v in chunk.items() if k != 'text'} 
                         for chunk in chunks]
        
        # Calculate statistics
        stats = {
            'total_characters': len(full_text),
            'total_chunks': len(chunks),
            'avg_chunk_size': sum(len(c) for c in chunk_texts) / len(chunk_texts) if chunks else 0,
            'file_format': Path(file_path).suffix.lower(),
            'source_segments': len(source_metadata)
        }
        
        return chunk_texts, chunk_metadata, stats
    
    def extract_keywords(self, text: str, max_keywords: int = 10) -> List[str]:
        """
        Extract potential keywords from text (simple frequency-based approach)
        
        Args:
            text: Text to extract keywords from
            max_keywords: Maximum number of keywords to return
            
        Returns:
            List of keywords
        """
        # Clean and tokenize
        text = self.clean_text(text.lower())
        words = re.findall(r'\b[a-z]{4,}\b', text)  # Words with 4+ characters
        
        # Common stop words to filter out
        stop_words = {
            'this', 'that', 'these', 'those', 'with', 'from', 'have', 'been',
            'were', 'will', 'would', 'could', 'should', 'their', 'there', 'where',
            'which', 'what', 'when', 'about', 'also', 'into', 'through', 'during',
            'before', 'after', 'above', 'below', 'between', 'under', 'again', 'further',
            'then', 'once', 'here', 'more', 'most', 'other', 'some', 'such', 'only',
            'same', 'than', 'very', 'just', 'your', 'they', 'them', 'their'
        }
        
        # Count frequencies
        word_freq = {}
        for word in words:
            if word not in stop_words:
                word_freq[word] = word_freq.get(word, 0) + 1
        
        # Sort by frequency and return top keywords
        sorted_words = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)
        keywords = [word for word, freq in sorted_words[:max_keywords]]
        
        return keywords
    
    def get_document_summary_stats(self, file_path: str) -> Dict:
        """
        Get summary statistics about a document without full processing
        
        Args:
            file_path: Path to document
            
        Returns:
            Dictionary of statistics
        """
        try:
            file_size = os.path.getsize(file_path)
            file_format = Path(file_path).suffix.lower()
            
            stats = {
                'file_size': file_size,
                'file_format': file_format,
                'file_name': Path(file_path).name
            }
            
            # Add format-specific stats
            if file_format == '.pdf' and PyPDF2:
                try:
                    with open(file_path, 'rb') as file:
                        pdf_reader = PyPDF2.PdfReader(file)
                        stats['num_pages'] = len(pdf_reader.pages)
                except:
                    pass
            elif file_format == '.docx' and DocxDocument:
                try:
                    doc = DocxDocument(file_path)
                    stats['num_paragraphs'] = len(doc.paragraphs)
                except:
                    pass
            
            return stats
            
        except Exception as e:
            return {'error': str(e)}


def process_uploaded_file(uploaded_file, upload_dir: str = "uploads") -> Tuple[str, str]:
    """
    Save an uploaded Streamlit file to disk
    
    Args:
        uploaded_file: Streamlit UploadedFile object
        upload_dir: Directory to save uploads
        
    Returns:
        Tuple of (file_path, file_type)
    """
    # Create upload directory if it doesn't exist
    os.makedirs(upload_dir, exist_ok=True)
    
    # Generate unique filename
    import uuid
    file_extension = Path(uploaded_file.name).suffix
    unique_filename = f"{uuid.uuid4()}{file_extension}"
    file_path = os.path.join(upload_dir, unique_filename)
    
    # Save file
    with open(file_path, "wb") as f:
        f.write(uploaded_file.getbuffer())
    
    return file_path, file_extension


def cleanup_file(file_path: str):
    """Delete a file from disk"""
    try:
        if os.path.exists(file_path):
            os.remove(file_path)
    except Exception as e:
        print(f"Error deleting file {file_path}: {e}")

#This is utils/rag_system.py
import os
from typing import List, Dict, Optional, Tuple
import numpy as np
import faiss
from openai import AzureOpenAI
import pickle


class RAGSystem:
    """Retrieval-Augmented Generation system using FAISS and Azure OpenAI"""
    
    def __init__(self, azure_api_key: str, azure_endpoint: str, 
                 azure_deployment_name: str, azure_api_version: str = "2024-02-15-preview",
                 embedding_model: str = "text-embedding-ada-002"):
        """
        Initialize RAG system with Azure OpenAI credentials
        
        Args:
            azure_api_key: Azure OpenAI API key
            azure_endpoint: Azure OpenAI endpoint URL
            azure_deployment_name: Deployment name for the chat model
            azure_api_version: API version
            embedding_model: Model name for embeddings
        """
        self.client = AzureOpenAI(
            api_key=azure_api_key,
            api_version=azure_api_version,
            azure_endpoint=azure_endpoint
        )
        self.deployment_name = azure_deployment_name
        self.embedding_model = embedding_model
        self.index = None
        self.chunks = []
        self.metadata = []
    
    def create_embeddings(self, texts: List[str]) -> np.ndarray:
        """
        Create embeddings for a list of texts using Azure OpenAI
        
        Args:
            texts: List of text strings to embed
            
        Returns:
            numpy array of embeddings
        """
        embeddings = []
        
        # Process in batches to avoid rate limits
        batch_size = 100
        for i in range(0, len(texts), batch_size):
            batch = texts[i:i + batch_size]
            
            response = self.client.embeddings.create(
                input=batch,
                model=self.embedding_model
            )
            
            batch_embeddings = [item.embedding for item in response.data]
            embeddings.extend(batch_embeddings)
        
        return np.array(embeddings, dtype='float32')
    
    def create_index(self, chunks: List[str], metadata: Optional[List[Dict]] = None) -> faiss.Index:
        """
        Create FAISS index from text chunks
        
        Args:
            chunks: List of text chunks
            metadata: Optional metadata for each chunk (page number, section, etc.)
            
        Returns:
            FAISS index
        """
        self.chunks = chunks
        self.metadata = metadata if metadata else [{"index": i} for i in range(len(chunks))]
        
        # Create embeddings
        embeddings = self.create_embeddings(chunks)
        
        # Create FAISS index
        dimension = embeddings.shape[1]  # Should be 1536 for text-embedding-ada-002
        self.index = faiss.IndexFlatL2(dimension)  # L2 distance
        self.index.add(embeddings)
        
        return self.index
    
    def save_index(self, index_path: str):
        """
        Save FAISS index and associated data to disk
        
        Args:
            index_path: Path to save the index (without extension)
        """
        if self.index is None:
            raise ValueError("No index to save. Create an index first.")
        
        # Create directory if it doesn't exist
        os.makedirs(os.path.dirname(index_path), exist_ok=True)
        
        # Save FAISS index
        faiss.write_index(self.index, f"{index_path}.faiss")
        
        # Save chunks and metadata
        with open(f"{index_path}.pkl", 'wb') as f:
            pickle.dump({
                'chunks': self.chunks,
                'metadata': self.metadata
            }, f)
    
    def load_index(self, index_path: str):
        """
        Load FAISS index and associated data from disk
        
        Args:
            index_path: Path to the index (without extension)
        """
        # Load FAISS index
        self.index = faiss.read_index(f"{index_path}.faiss")
        
        # Load chunks and metadata
        with open(f"{index_path}.pkl", 'rb') as f:
            data = pickle.load(f)
            self.chunks = data['chunks']
            self.metadata = data['metadata']
    
    def search(self, query: str, k: int = 5) -> List[Tuple[str, Dict, float]]:
        """
        Search for relevant chunks using the query
        
        Args:
            query: Search query
            k: Number of results to return
            
        Returns:
            List of tuples (chunk_text, metadata, distance)
        """
        if self.index is None:
            raise ValueError("No index loaded. Create or load an index first.")
        
        # Create query embedding
        query_embedding = self.create_embeddings([query])
        
        # Search
        distances, indices = self.index.search(query_embedding, k)
        
        # Return results
        results = []
        for idx, distance in zip(indices[0], distances[0]):
            if idx < len(self.chunks):  # Valid index
                results.append((
                    self.chunks[idx],
                    self.metadata[idx],
                    float(distance)
                ))
        
        return results
    
    def generate_response(self, query: str, context_chunks: List[str], 
                         chat_history: Optional[List[Dict]] = None,
                         system_prompt: Optional[str] = None,
                         temperature: float = 0.7,
                         max_tokens: int = 1000) -> str:
        """
        Generate a response using Azure OpenAI with RAG context
        
        Args:
            query: User's question
            context_chunks: Retrieved relevant chunks
            chat_history: Previous chat messages
            system_prompt: Custom system prompt
            temperature: Response randomness (0-1)
            max_tokens: Maximum tokens in response
            
        Returns:
            Generated response
        """
        # Build context from chunks
        context = "\n\n".join([f"[Context {i+1}]\n{chunk}" 
                               for i, chunk in enumerate(context_chunks)])
        
        # Default system prompt
        if system_prompt is None:
            system_prompt = """You are a helpful AI study assistant. Answer questions based on the provided context from the user's documents. 
If the context doesn't contain enough information to answer the question, say so clearly. 
Be concise, accurate, and educational in your responses."""
        
        # Build messages
        messages = [
            {"role": "system", "content": system_prompt}
        ]
        
        # Add chat history if provided
        if chat_history:
            messages.extend(chat_history)
        
        # Add current query with context
        user_message = f"""Context from your documents:
{context}

Question: {query}

Please answer based on the context above."""
        
        messages.append({"role": "user", "content": user_message})
        
        # Generate response
        response = self.client.chat.completions.create(
            model=self.deployment_name,
            messages=messages,
            temperature=temperature,
            max_tokens=max_tokens
        )
        
        return response.choices[0].message.content
    
    def chat(self, query: str, k: int = 5, 
             chat_history: Optional[List[Dict]] = None,
             temperature: float = 0.7) -> Tuple[str, List[Dict]]:
        """
        Complete RAG chat flow: retrieve relevant chunks and generate response
        
        Args:
            query: User's question
            k: Number of chunks to retrieve
            chat_history: Previous chat messages
            temperature: Response randomness
            
        Returns:
            Tuple of (response, sources_used)
        """
        # Search for relevant chunks
        search_results = self.search(query, k=k)
        
        # Extract chunks and metadata
        context_chunks = [result[0] for result in search_results]
        sources = [result[1] for result in search_results]
        
        # Generate response
        response = self.generate_response(
            query=query,
            context_chunks=context_chunks,
            chat_history=chat_history,
            temperature=temperature
        )
        
        return response, sources
    
    def generate_quiz_questions(self, num_questions: int = 5, 
                               difficulty: str = "medium",
                               topic: Optional[str] = None) -> List[Dict]:
        """
        Generate quiz questions from the document content
        
        Args:
            num_questions: Number of questions to generate
            difficulty: Difficulty level (easy, medium, hard)
            topic: Optional specific topic to focus on
            
        Returns:
            List of quiz questions with answers
        """
        # Sample chunks for quiz generation (more chunks = better coverage)
        num_chunks = min(10, len(self.chunks))
        sample_indices = np.random.choice(len(self.chunks), num_chunks, replace=False)
        sample_chunks = [self.chunks[i] for i in sample_indices]
        
        context = "\n\n".join(sample_chunks)
        
        topic_text = f" focusing on {topic}" if topic else ""
        
        prompt = f"""Based on the following content, generate {num_questions} multiple-choice questions at a {difficulty} difficulty level{topic_text}.

Content:
{context}

For each question, provide:
1. The question text
2. Four answer options (A, B, C, D)
3. The correct answer (letter)
4. A brief explanation of why it's correct

Format your response as a JSON array of objects with keys: question, option_a, option_b, option_c, option_d, correct_answer, explanation"""
        
        response = self.client.chat.completions.create(
            model=self.deployment_name,
            messages=[
                {"role": "system", "content": "You are an educational quiz generator. Create clear, accurate questions."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.8,
            max_tokens=2000
        )
        
        # Parse response ()
        return response.choices[0].message.content
    
    def generate_flashcards(self, num_cards: int = 10,
                           topic: Optional[str] = None) -> List[Dict]:
        """
        Generate flashcards from the document content
        
        Args:
            num_cards: Number of flashcards to generate
            topic: Optional specific topic to focus on
            
        Returns:
            List of flashcards with front/back
        """
        # Sample chunks for flashcard generation
        num_chunks = min(10, len(self.chunks))
        sample_indices = np.random.choice(len(self.chunks), num_chunks, replace=False)
        sample_chunks = [self.chunks[i] for i in sample_indices]
        
        context = "\n\n".join(sample_chunks)
        
        topic_text = f" focusing on {topic}" if topic else ""
        
        prompt = f"""Based on the following content, generate {num_cards} flashcards{topic_text}.

Content:
{context}

For each flashcard, provide:
- Front: A question, term, or concept
- Back: The answer, definition, or explanation

Format your response as a JSON array of objects with keys: front, back"""
        
        response = self.client.chat.completions.create(
            model=self.deployment_name,
            messages=[
                {"role": "system", "content": "You are an educational flashcard generator. Create clear, concise cards."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=2000
        )
        
        return response.choices[0].message.content
    
    def summarize_document(self, max_length: int = 500) -> str:
        """
        Generate a summary of the entire document
        
        Args:
            max_length: Maximum length of summary in words
            
        Returns:
            Document summary
        """
        # Sample chunks across the document
        num_chunks = min(20, len(self.chunks))
        step = len(self.chunks) // num_chunks if num_chunks > 0 else 1
        sample_chunks = [self.chunks[i] for i in range(0, len(self.chunks), step)]
        
        context = "\n\n".join(sample_chunks)
        
        prompt = f"""Please provide a comprehensive summary of the following document in approximately {max_length} words. 
Cover the main topics, key concepts, and important points.

Document content:
{context}"""
        
        response = self.client.chat.completions.create(
            model=self.deployment_name,
            messages=[
                {"role": "system", "content": "You are a document summarization expert."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.5,
            max_tokens=max_length * 2  # Rough token estimation
        )
        
        return response.choices[0].message.content


#This is app.py

import streamlit as st
from pathlib import Path
import sys

# Add project root to path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from database.db_manager import DatabaseManager
from utils.auth import AuthManager

# Page configuration
st.set_page_config(
    page_title="AI Study Assistant",
    page_icon="üìö",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
    <style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .stButton>button {
        width: 100%;
        border-radius: 5px;
        height: 3em;
        font-weight: 500;
    }
    .sidebar .stButton>button {
        margin-top: 0.5rem;
    }
    div[data-testid="stSidebarNav"] {
        display: none;
    }
    </style>
""", unsafe_allow_html=True)

# Initialize database and auth
@st.cache_resource
def get_database():
    """Initialize and return database manager"""
    return DatabaseManager("study_assistant.db")

@st.cache_resource
def get_auth_manager(_db):
    """Initialize and return auth manager"""
    return AuthManager(_db)

# Get instances
db = get_database()
auth = get_auth_manager(db)

# Initialize session state for navigation
if 'current_page' not in st.session_state:
    st.session_state.current_page = 'home'

if 'selected_subject_id' not in st.session_state:
    st.session_state.selected_subject_id = None

if 'selected_document_id' not in st.session_state:
    st.session_state.selected_document_id = None

# Navigation functions
def navigate_to(page: str):
    """Navigate to a specific page"""
    st.session_state.current_page = page
    st.rerun()

def show_sidebar():
    """Display sidebar with improved styling and navigation"""
    with st.sidebar:
        # Header with emoji and styling
       with st.sidebar:
        st.markdown(
            """
            <div style="text-align:center; padding: 1rem 0;">
                <img src="https://lecturaai.com/images/logo.png" 
                    style="width:auto; border-radius:10px; margin-top:0; margin-bottom:0px;">
            </div>
            """,
            unsafe_allow_html=True
        )
        st.markdown("---")  

        if auth.is_authenticated():
            # User info card
            st.markdown(
                f"""
                <div style="background:linear-gradient(135deg,#667eea,#764ba2);
                            padding:1rem; border-radius:10px; color:white; margin-bottom:1rem;">
                    <strong>üëã Welcome, {auth.get_current_username()}!</strong>
                </div>
                """,
                unsafe_allow_html=True
            )

            # Dashboard navigation
            st.markdown("### üìä Dashboard")
            nav_items = [
                ("üè† Overview", "dashboard"),
                ("üìñ Subjects", "subjects"),
                ("üìÑ Documents", "documents"),
                ("üí¨ Chat", "chat"),
                ("‚ùì Quizzes", "quiz"),
                ("üé¥ Flashcards", "flashcard"),
                ("üìÖ Study Planner", "planner"),
            ]
            for label, page in nav_items:
                if st.button(label, use_container_width=True):
                    navigate_to(page)

            st.markdown("---")

            # Settings and logout
            if st.button("‚öôÔ∏è Settings", use_container_width=True):
                navigate_to("settings")
            if st.button("üö™ Logout", use_container_width=True):
                auth.logout()
                navigate_to("home")

        else:
            # Not authenticated
            st.markdown("### üîë Access")
            if st.button("üè† Home", use_container_width=True):
                navigate_to("home")
            if st.button("üîê Login", use_container_width=True):
                navigate_to("login")
            if st.button("üìù Sign Up", use_container_width=True):
                navigate_to("signup")

        st.markdown("---")

        # About section with icons
        st.markdown("### ‚ÑπÔ∏è About")
        st.markdown(
            """
            <div style="font-size:0.9rem; line-height:1.6;">
                <ul style="padding-left:1rem;">
                    <li>üìö Organize study materials</li>
                    <li>üí¨ Chat with your documents</li>
                    <li>‚ùì Generate quizzes</li>
                    <li>üé¥ Create flashcards</li>
                    <li>üìÖ Plan your studies</li>
                </ul>
            </div>
            """,
            unsafe_allow_html=True
        )
# Page routing
def route_page():
    """Route to the appropriate page based on current_page state"""
    page = st.session_state.current_page
    
    # Import pages dynamically to avoid circular imports
    if page == 'home':
        from pages.home import show_home_page
        show_home_page(auth, navigate_to)
    
    elif page == 'login':
        from pages.login import show_login_page
        show_login_page(auth, navigate_to)
    
    elif page == 'signup':
        from pages.signup import show_signup_page
        show_signup_page(auth, navigate_to)
    
    elif page == 'dashboard':
        auth.require_authentication()
        from pages.dashboard.main import show_dashboard_page
        show_dashboard_page(db, auth, navigate_to)
    
    elif page == 'subjects':
        auth.require_authentication()
        from pages.dashboard.subjects import show_subjects_page
        show_subjects_page(db, auth, navigate_to)
    
    elif page == 'documents':
        auth.require_authentication()
        from pages.dashboard.documents import show_documents_page
        show_documents_page(db, auth, navigate_to)
    
    elif page == 'chat':
        auth.require_authentication()
        from pages.dashboard.chat import show_chat_page
        show_chat_page(db, auth, navigate_to)
    
    elif page == 'quiz':
        auth.require_authentication()
        from pages.dashboard.quiz import show_quiz_page
        show_quiz_page(db, auth, navigate_to)
    
    elif page == 'flashcard':
        auth.require_authentication()
        from pages.dashboard.flashcard import show_flashcard_page
        show_flashcard_page(db, auth, navigate_to)
    
    elif page == 'planner':
        auth.require_authentication()
        from pages.dashboard.planner import show_planner_page
        show_planner_page(db, auth, navigate_to)
    
    elif page == 'settings':
        auth.require_authentication()
        from pages.dashboard.settings import show_settings_page
        show_settings_page(db, auth, navigate_to)
    
    else:
        st.error(f"Page '{page}' not found")
        if st.button("Go to Home"):
            navigate_to('home')

# Main app
def main():
    """Main application entry point"""
    
    # Show sidebar
    show_sidebar()
    
    # Route to appropriate page
    route_page()

if __name__ == "__main__":
    main()